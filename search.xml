<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习系列1——Pytorch 图像分类(LeNet)</title>
      <link href="/2022/11/21/shen-du-xue-xi-xi-lie-1-pytorch-tu-xiang-fen-lei-lenet/"/>
      <url>/2022/11/21/shen-du-xue-xi-xi-lie-1-pytorch-tu-xiang-fen-lei-lenet/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要是参照 B 站 UP 主 <a href="https://space.bilibili.com/18161609" target="_blank" rel="noopener">霹雳吧啦Wz</a> 的视频学习笔记，参考的相关资料在文末<strong>参照</strong>栏给出，包括实现代码和文中用的一些图片。</p><p><strong>整个工程已经上传个人的 github <a href="https://github.com/lovewinds13/QYQXDeepLearning" target="_blank" rel="noopener">https://github.com/lovewinds13/QYQXDeepLearning</a> ，下载即可直接测试，数据集文件因为比较大，已经删除了，按照下文教程下载即可。</strong></p><hr><h1 id="2-LeNet"><a href="#2-LeNet" class="headerlink" title="2. LeNet"></a>2. LeNet</h1><p>LeNet 可以说是第一个卷积神经网络，LeNet-5。LeNet-5 由Y. LeCun 在 1998 年发表的文章《Gradient-Based Learning Applied to Document Recognition 》中正式提出，应用于数字识别问题。LeNet 包含了卷积网络的基本组件，如下图：可以看到卷积层，池化层，全连接层。</p><h2 id="2-1-网络结构"><a href="#2-1-网络结构" class="headerlink" title="2.1 网络结构"></a>2.1 网络结构</h2><p><img src="https://img-blog.csdnimg.cn/d1041f50467f478d98c99b8789cc1315.png#pic_center" alt><br>LeNet-5 由 2 个卷积层，2 个池化层（下采样层），3 个全连接层组成。</p><table><thead><tr><th align="center">层</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">输入层（INPUT）</td><td align="center">32 X 32 X 1 的图片（长、宽、色彩）</td></tr><tr><td align="center">卷积层（C1）</td><td align="center">输入 32 X 32 X 1，卷积核 5 X 5 X 6，步长（stride）为 1， 输出  28 X 28 X 6 的特征图</td></tr><tr><td align="center">池化层（S2）</td><td align="center">输入 28 X 28 X 6， 过滤器为 2 X 2，输出 14 X 14 X 6</td></tr><tr><td align="center">卷积层（C3）</td><td align="center">输入 14 X 14 X 6，卷积核 5 X 5 X 16，步长（stride）为 1， 输出 10 X 10 X 16 的特征图</td></tr><tr><td align="center">池化层（S4）</td><td align="center">输入 10 X 10 X 16， 过滤器为 2 X 2，输出 5 X 5  X 16</td></tr><tr><td align="center">全连接层（C5）</td><td align="center">输入 5  X 5 X 16，卷积核 5 X 5 X 120，步长（stride）为 1，输出 1 X 1 X 120 的特征图</td></tr><tr><td align="center">全连接层（F6）</td><td align="center">输入 120 个节点，输出 84 个节点</td></tr><tr><td align="center">全连接层（OUTPUT）</td><td align="center">输入 84 个节点，输出 10 个节点</td></tr></tbody></table><p><strong>模型框图：</strong><br><img src="https://img-blog.csdnimg.cn/5a12fdd4933b4b5982a6bb929ecb847f.png#pic_center" alt></p><h1 id="3-demo-实现"><a href="#3-demo-实现" class="headerlink" title="3. demo 实现"></a>3. demo 实现</h1><p>针对 CIFAR10 数据集，进行图像识别。</p><p>整个过程实现流程：</p><p><img src="https://img-blog.csdnimg.cn/0af25342614b4a6cb46dc556c82ecf90.png#pic_center" alt></p><h2 id="3-1-demo-结构："><a href="#3-1-demo-结构：" class="headerlink" title="3.1 demo 结构："></a>3.1 demo 结构：</h2><p>demo 包含 model.py ，train.py，predict.py 三个文件。<br><img src="https://img-blog.csdnimg.cn/9fe6a97330c147479a6633f67d54d4bb.png#pic_center" alt></p><h2 id="3-2-model-py"><a href="#3-2-model-py" class="headerlink" title="3.2 model.py"></a>3.2 model.py</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""模型"""</span><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F<span class="token keyword">class</span> <span class="token class-name">LeNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 集成nn.Module父类</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>LeNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 看一下具体的参数</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>                               out_channels<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span>                               kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>                               stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                               padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>                               bias<span class="token operator">=</span><span class="token boolean">True</span>                               <span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pool1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>pool2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">32</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># self.relu = nn.ReLU(inplace=True)</span>    <span class="token comment" spellcheck="true"># 正向传播</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输入: (3, 32, 32), 输出: (16, 28, 28)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>pool1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出: (16, 14, 14)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出: (32, 10, 10)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>pool2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出: (32, 5, 5)</span>        x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出: (32*5*5)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出: (120)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出: (84)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc3<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出(10)</span>        <span class="token keyword">return</span> x<span class="token triple-quoted-string string">"""调试信息, 查看模型参数传递"""</span><span class="token comment" spellcheck="true"># import torch</span><span class="token comment" spellcheck="true"># input1 = torch.rand([32, 3, 32, 32])</span><span class="token comment" spellcheck="true"># modelx = LeNet()</span><span class="token comment" spellcheck="true"># print(modelx)</span><span class="token comment" spellcheck="true"># output = modelx(input1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-卷积后的图像尺寸"><a href="#3-2-1-卷积后的图像尺寸" class="headerlink" title="3.2.1 卷积后的图像尺寸"></a>3.2.1 卷积后的图像尺寸</h3><p>（1）正方形图像：输入大小 W X W，卷积核大小 F X F，步长 S，Padding 为 P，卷积之后输出大小为 N XN ，N 的计算如下：<br><img src="https://img-blog.csdnimg.cn/c5e58dbddbaa48c0ab06b80aef25a181.png#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python"> x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输入: (3, 32, 32), 输出: (16, 28, 28)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）矩形图像：输入大小 H X W，卷积核大小 F X F，步长 S，Padding 为 P，卷积之后输出大小计算如下：<br><img src="https://img-blog.csdnimg.cn/676adffad8f346cb8bf3510875fe02fa.png#pic_center" alt></p><h3 id="3-2-2-池化后的图像尺寸"><a href="#3-2-2-池化后的图像尺寸" class="headerlink" title="3.2.2 池化后的图像尺寸"></a>3.2.2 池化后的图像尺寸</h3><p>输入大小 H X W，卷积核尺寸 F X F，步长 S，池化之后输出大小计算如下：</p><p><img src="https://img-blog.csdnimg.cn/b7fca7f06ffe4b5b82766e476231c417.png#pic_center" alt></p><pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> self<span class="token punctuation">.</span>pool1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输入: (16, 28, 28), 输出: (16, 14, 14)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-3-Tensor-展平"><a href="#3-2-3-Tensor-展平" class="headerlink" title="3.2.3 Tensor 展平"></a>3.2.3 Tensor 展平</h3><p>经过前面一层处理，数据输出为三维 Tensor  (32, 5, 5)，使用 view() 方法来展平数据。</p><pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出: (32*5*5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-train-py"><a href="#3-3-train-py" class="headerlink" title="3.3 train.py"></a>3.3 train.py</h2><h3 id="3-3-1-导入包"><a href="#3-3-1-导入包" class="headerlink" title="3.3.1 导入包"></a>3.3.1 导入包</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">from</span> model <span class="token keyword">import</span> LeNet<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>transforms <span class="token keyword">as</span> transforms<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-2-数据集预处理"><a href="#3-3-2-数据集预处理" class="headerlink" title="3.3.2 数据集预处理"></a>3.3.2 数据集预处理</h3><pre class="line-numbers language-python"><code class="language-python">    transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>        transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 数据转为张量</span>        transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 标准化处理</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将数据转成张量，并做标准化处理。</p><h3 id="3-3-3-导入数据集"><a href="#3-3-3-导入数据集" class="headerlink" title="3.3.3 导入数据集"></a>3.3.3 导入数据集</h3><p>数据集包括训练集和测试集，设置 download=True，自动从 Pytorch 网站下载数据集。下图为开始下载数据集。</p><p><img src="https://img-blog.csdnimg.cn/aca9e053c8d3450fb31ca13c55aeef73.png#pic_center" alt></p><h3 id="3-3-4-数据集测试"><a href="#3-3-4-数据集测试" class="headerlink" title="3.3.4 数据集测试"></a>3.3.4 数据集测试</h3><p>可通过下面的代码，查看数据集图片。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># 定义的分类标签</span>    class_labels <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'plane'</span><span class="token punctuation">,</span> <span class="token string">'car'</span><span class="token punctuation">,</span> <span class="token string">'bird'</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'deer'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token string">'frog'</span><span class="token punctuation">,</span> <span class="token string">'horse'</span><span class="token punctuation">,</span> <span class="token string">'ship'</span><span class="token punctuation">,</span> <span class="token string">'truck'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 查看数据集的图片</span>    <span class="token keyword">def</span> <span class="token function">img_show</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>        img <span class="token operator">=</span> img <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.5</span>        np_img <span class="token operator">=</span> img<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>        plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>np_img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 查看数据集中的5张图像</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">" %5s "</span> <span class="token operator">%</span> class_labels<span class="token punctuation">[</span>val_label<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img_show<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>val_image<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 Pytorch Tensor 读入数据时，维度参数顺序发生了变化。<br>Pytorch Tensor 对应 [深度，高度，宽度]，而原始数据是[高度，宽度,深度]。故通过下面的代码调整，才能正常显示图片。</p><pre class="line-numbers language-python"><code class="language-python"> plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>np_img<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>导入数据集：</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入训练集数据(50000张图片)</span>    train_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># root: 数据集存储路径</span>                                             train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 数据集为训练集</span>                                             download<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># download: True时下载数据集(下载完成修改为False)</span>                                             transform<span class="token operator">=</span>transform    <span class="token comment" spellcheck="true"># 数据预处理</span>                                             <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#   加载训练集</span>    train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_set<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true"># 加载训练集</span>                                               batch_size<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true"># batch 大小</span>                                               shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># 是否随机打乱训练集</span>                                               num_workers<span class="token operator">=</span><span class="token number">0</span>    <span class="token comment" spellcheck="true"># 使用的线程数量</span>                                               <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 导入测试集(10000张图片)</span>    val_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span>                                           train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true"># 数据集为测试集</span>                                           download<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                           transform<span class="token operator">=</span>transform                                           <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 加载测试集数据</span>    val_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>val_set<span class="token punctuation">,</span>                                             batch_size<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true"># 测试集batch大小</span>                                             shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                             num_workers<span class="token operator">=</span><span class="token number">0</span>                                             <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取测试集中的图片和标签</span>    val_data_iter <span class="token operator">=</span> iter<span class="token punctuation">(</span>val_loader<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># val_image, val_label = val_data_iter.next()</span>    val_image<span class="token punctuation">,</span> val_label <span class="token operator">=</span> next<span class="token punctuation">(</span>val_data_iter<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#python 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4-训练过程"><a href="#3-3-4-训练过程" class="headerlink" title="3.3.4 训练过程"></a>3.3.4 训练过程</h3><p>（1）<strong>CPU 训练代码：</strong></p><pre class="line-numbers language-python"><code class="language-python"> net <span class="token operator">=</span> LeNet<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 用于训练的网络模型</span>    <span class="token comment" spellcheck="true"># 指定GPU or CPU 进行训练</span>    net<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">)</span>    loss_function <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 损失函数(交叉熵函数)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 优化器(训练参数, 学习率)</span>    <span class="token comment" spellcheck="true"># 训练的轮数</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>        running_loss <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token comment" spellcheck="true"># 遍历训练集, 从0开始</span>        <span class="token keyword">for</span> step<span class="token punctuation">,</span> data <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> data   <span class="token comment" spellcheck="true"># 得到训练集图片和标签</span>            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 清除历史梯度</span>            outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 正向传播</span>            loss <span class="token operator">=</span> loss_function<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 损失计算</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 反向传播</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#优化器更新参数</span>            <span class="token comment" spellcheck="true"># 用于打印精确率等评估参数</span>            running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> step <span class="token operator">%</span> <span class="token number">500</span> <span class="token operator">==</span> <span class="token number">499</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 500步打印一次</span>                <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>val_image<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 传入测试集数据</span>                    predict_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>max<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    accuracy <span class="token operator">=</span> torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_y<span class="token punctuation">,</span> val_label<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> val_label<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 打印训练轮数、精确率等</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[%d, %5d] train_loss: %.3f   test_accuracy: %.3f"</span> <span class="token operator">%</span>                          <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span> <span class="token number">500</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span>                          <span class="token punctuation">)</span>                    running_loss <span class="token operator">=</span> <span class="token number">0.0</span>        end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"cost time = "</span><span class="token punctuation">,</span> end_time <span class="token operator">-</span> start_time<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Finished trainning"</span><span class="token punctuation">)</span>    save_path <span class="token operator">=</span> <span class="token string">"./LeNet.pth"</span>    torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> save_path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 保存训练输出的模型文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>训练打印信息：<br><img src="https://img-blog.csdnimg.cn/7cc78c962c6540768dc63e3d5113b0c0.png#pic_center" alt>（2）<strong>GPU 训练代码：</strong><br>需要将训练设备指定为 GPU，且需要修改对应数据和标签。</p><pre class="line-numbers language-python"><code class="language-python">net <span class="token operator">=</span> LeNet<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 用于训练的网络模型</span>    <span class="token comment" spellcheck="true"># 指定GPU or CPU 进行训练</span>    net<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cuda"</span><span class="token punctuation">)</span>    loss_function <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 损失函数(交叉熵函数)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 优化器(训练参数, 学习率)</span>    <span class="token comment" spellcheck="true"># 训练的轮数</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        running_loss <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token comment" spellcheck="true"># 遍历训练集, 从0开始</span>        <span class="token keyword">for</span> step<span class="token punctuation">,</span> data <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> data   <span class="token comment" spellcheck="true"># 得到训练集图片和标签</span>            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 清除历史梯度</span>            outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 正向传播</span>            loss <span class="token operator">=</span> loss_function<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 损失计算</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 反向传播</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#优化器更新参数</span>            <span class="token comment" spellcheck="true"># 用于打印精确率等评估参数</span>            running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> step <span class="token operator">%</span> <span class="token number">500</span> <span class="token operator">==</span> <span class="token number">499</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 500步打印一次</span>                <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>val_image<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 传入测试集数据</span>                    predict_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>max<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                    accuracy <span class="token operator">=</span> torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_y<span class="token punctuation">,</span> val_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> val_label<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># 打印训练轮数、精确率等</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[%d, %5d] train_loss: %.3f   test_accuracy: %.3f"</span> <span class="token operator">%</span>                          <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span> <span class="token number">500</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span>                          <span class="token punctuation">)</span>                    running_loss <span class="token operator">=</span> <span class="token number">0.0</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Finished trainning"</span><span class="token punctuation">)</span>    save_path <span class="token operator">=</span> <span class="token string">"./LeNet.pth"</span>    torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> save_path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 保存训练输出的模型文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对比可发现，GPU 的速度快于 CPU。</p><p><strong>注：</strong><br>本文采用 pycharm 开发，需要安装对应 CUDA，具体的版本需要查看自己电脑对应的 GPU 型号，然后下载 CUDA 安装。本文的信息如下：</p><p><img src="https://img-blog.csdnimg.cn/0cd4efcd8e8c494dbaffd5f76a571aaa.png#pic_center" alt></p><h2 id="3-4-predict-py"><a href="#3-4-predict-py" class="headerlink" title="3.4. predict.py"></a>3.4. predict.py</h2><p>此文件为模型测试代码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">""""测试"""</span><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>transforms <span class="token keyword">as</span> transforms<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> model <span class="token keyword">import</span> LeNet<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>        transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>    data_class <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'plane'</span><span class="token punctuation">,</span> <span class="token string">'car'</span><span class="token punctuation">,</span> <span class="token string">'bird'</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'deer'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token string">'frog'</span><span class="token punctuation">,</span> <span class="token string">'horse'</span><span class="token punctuation">,</span> <span class="token string">'ship'</span><span class="token punctuation">,</span> <span class="token string">'truck'</span><span class="token punctuation">)</span>    net <span class="token operator">=</span> LeNet<span class="token punctuation">(</span><span class="token punctuation">)</span>    net<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'LeNet.pth'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># net.load_state_dict(torch.load('LeNet.pth', map_location=torch.device("cpu")))</span>    test_image <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'cat_test2.jpg'</span><span class="token punctuation">)</span>    test_image <span class="token operator">=</span> transform<span class="token punctuation">(</span>test_image<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># [C H W]</span>    test_image <span class="token operator">=</span> torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>test_image<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># [N C H W]</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>test_image<span class="token punctuation">)</span>        predict <span class="token operator">=</span> torch<span class="token punctuation">.</span>max<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"It is {data_class[int(predict)]}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试图片为：cat_test2.jpg<br><img src="https://img-blog.csdnimg.cn/5f13ce6f40cf42abab00680af42486f4.jpeg#pic_center" alt><br>测试结果：<br><img src="https://img-blog.csdnimg.cn/cdff445c0dbd462e81f723c05f3ec8b1.png#pic_center" alt></p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://blog.csdn.net/m0_37867091/article/details/107136477" target="_blank" rel="noopener">pytorch图像分类篇：2.pytorch官方demo实现一个分类器(LeNet)</a></li><li><a href="https://www.bilibili.com/video/BV187411T7Ye/?spm_id_from=333.999.0.0&vd_source=103efe685ad4c1216c5d837f7dd7d25c" target="_blank" rel="noopener">B站——2.1 pytorch官方demo(Lenet)</a></li><li><a href="https://blog.sciencenet.cn/home.php?mod=space&uid=3428464&do=blog&id=1255308" target="_blank" rel="noopener">Pytorch中nn.Conv1d、Conv2D与BatchNorm1d、BatchNorm2d函数 </a></li><li><a href="https://blog.csdn.net/STATEABC/article/details/123661612?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-123661612-blog-107136477.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-123661612-blog-107136477.pc_relevant_aa&utm_relevant_index=4" target="_blank" rel="noopener">pytorch官方demo实现图像分类(LeNet)</a></li><li><a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing" target="_blank" rel="noopener">UP主代码——Test1_official_demo</a></li><li><a href="https://pytorch.apachecn.org/#/" target="_blank" rel="noopener">Pytorch中文</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/102926037" target="_blank" rel="noopener">pytorch中的卷积操作详解</a></li><li><a href="https://axon.cs.byu.edu/~martinez/classes/678/Papers/Convolution_nets.pdf" target="_blank" rel="noopener">LeNet 论文地址</a></li><li><a href="https://www.ruanx.net/lenet/" target="_blank" rel="noopener">LeNet：第一个卷积神经网络</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> DeepLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> LeNet </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习系列2——Pytorch 图像分类(AlexNet)</title>
      <link href="/2022/11/21/shen-du-xue-xi-xi-lie-2-pytorch-tu-xiang-fen-lei-alexnet/"/>
      <url>/2022/11/21/shen-du-xue-xi-xi-lie-2-pytorch-tu-xiang-fen-lei-alexnet/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要是参照 B 站 UP 主 <a href="https://space.bilibili.com/18161609" target="_blank" rel="noopener">霹雳吧啦Wz</a> 的视频学习笔记，参考的相关资料在文末<strong>参照</strong>栏给出，包括实现代码和文中用的一些图片。</p><p><strong>整个工程已经上传个人的 github <a href="https://github.com/lovewinds13/QYQXDeepLearning" target="_blank" rel="noopener">https://github.com/lovewinds13/QYQXDeepLearning</a> ，下载即可直接测试，数据集文件因为比较大，已经删除了，按照下文教程下载即可。</strong></p><p>论文下载：<a href="https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a></p><h1 id="2-AlexNet"><a href="#2-AlexNet" class="headerlink" title="2. AlexNet"></a>2. AlexNet</h1><p>AlexNet 是 2012 年 ISLVRC 2012（ImageNet Large Scale Visual Recognition Challenge） 竞赛的冠军网络， 分类准确率由传统的 70%+ 提升到 80%+。它是由 Hinton 和他的学生Alex Krizhevsky设计的。 </p><p>AlexNet 2012 年在大规模图像识别中一起绝尘，从此引领了深度神经网络的热潮。另外，AlexNet 提出的 ReLU 激活函数， LRN， GPU 加速，数据增强，Dropout 失活部分神经元等方式，深刻的影响了后续的神经网络。</p><h2 id="2-1-网络框架"><a href="#2-1-网络框架" class="headerlink" title="2.1 网络框架"></a>2.1 网络框架</h2><p><img src="https://img-blog.csdnimg.cn/65517181ecc44f59a61d75476534a62e.png#pic_center" alt></p><p>AlexNet 共有 8 层组成，其中包括 5 个卷积层，3 个全连接层。各层参数如下：<br><img src="https://img-blog.csdnimg.cn/2889f07a00864f6c9e042b91adbd5d82.png#pic_center" alt><br>计算公式参考<a href="https://blog.csdn.net/wwt18811707971/article/details/127820299?spm=1001.2014.3001.5501" target="_blank" rel="noopener">深度学习系列1——Pytorch 图像分类(LeNet)</a>，此处不再列出。</p><p>其传输框图如下：<br><img src="https://img-blog.csdnimg.cn/fa3cd74c126b47e69ea08cf42c095b3b.png#pic_center" alt></p><p>卷积层1数据传输如下：</p><p><img src="https://img-blog.csdnimg.cn/db825339199c47338ffa6259f3d84c95.png#pic_center" alt><br>其余层依此类似，只需类推。</p><h2 id="2-2-补充"><a href="#2-2-补充" class="headerlink" title="2.2 补充"></a>2.2 补充</h2><h3 id="2-2-1-过拟合"><a href="#2-2-1-过拟合" class="headerlink" title="2.2.1 过拟合"></a>2.2.1 过拟合</h3><p>根本原因是特征维度过多， <strong>模型假设过于复杂， 参数过多， 训练数据过少</strong>， 噪声过多，导致拟合的函数完美的预测训练集， 但对新数据的测试集预测结果差。 过度的拟合了训练数据， 而没有考虑到泛化能力。</p><p>过拟合主要受数据量和模型复杂度的影响。</p><p><img src="https://img-blog.csdnimg.cn/f207555d1d264e88a92f0008318dca93.png#pic_center" alt></p><p>一句话就是：平时作业完成的非常好，但是考试就歇菜了。</p><h3 id="2-2-2-Dropout"><a href="#2-2-2-Dropout" class="headerlink" title="2.2.2 Dropout"></a>2.2.2 Dropout</h3><p>网络正向传播过程中随机失活一部分神经元，减少过拟合。Dropout 主要用在全连接层。</p><p><img src="https://img-blog.csdnimg.cn/fe739a334c3f4fb6bb5e73f3f6be2815.png#pic_center" alt></p><h1 id="3-demo-实现"><a href="#3-demo-实现" class="headerlink" title="3. demo 实现"></a>3. demo 实现</h1><h2 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h2><p>本文使用花分类数据集，下载链接: <a href="http://download.tensorflow.org/example_images/flower_photos.tgz" target="_blank" rel="noopener">花分类数据集——http://download.tensorflow.org/example_images/flower_photos.tgz</a></p><p><img src="https://img-blog.csdnimg.cn/527b7a338ae7489f910675254675615c.png#pic_center" alt></p><p>数据集划分参考这个<a href="https://blog.csdn.net/m0_37867091/article/details/107150142" target="_blank" rel="noopener">pytorch图像分类篇：3.搭建AlexNet并训练花分类数据集</a></p><h2 id="3-1-demo-结构："><a href="#3-1-demo-结构：" class="headerlink" title="3.1 demo 结构："></a>3.1 demo 结构：</h2><p><img src="https://img-blog.csdnimg.cn/cf4ef19a778f4035aa038af45bff70af.png#pic_center" alt></p><p>在 CPU 训练的基础上，为了修改为 GPU 训练，因此单独修改了一个文件 train_gpu.py。</p><h2 id="3-2-model-py"><a href="#3-2-model-py" class="headerlink" title="3.2 model.py"></a>3.2 model.py</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""模型"""</span><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torch<span class="token keyword">class</span> <span class="token class-name">AlexNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_classes<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> init_weights<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>AlexNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token triple-quoted-string string">"""        特征提取        """</span>        self<span class="token punctuation">.</span>features <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true"># 输入[3, 224, 224] 输出[48, 55, 55]</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 输出 [48,27,27]</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true"># 输出 [128, 27, 27]</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 输出 [128, 13, 13]</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 输出[192, 13, 13]</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 输出[192, 13, 13]</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 输出[128, 13, 13]</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出 [128, 6, 6]</span>        <span class="token punctuation">)</span>        <span class="token triple-quoted-string string">"""        分类器        """</span>        self<span class="token punctuation">.</span>classifier <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># Dropout 随机失活神经元, 比例诶0.5</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">128</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token keyword">if</span> init_weights<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_initialize_weights<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>features<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> torch<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>x<span class="token punctuation">,</span> start_dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>classifier<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x    <span class="token triple-quoted-string string">"""    权重初始化    """</span>    <span class="token keyword">def</span> <span class="token function">_initialize_weights</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> m <span class="token keyword">in</span> self<span class="token punctuation">.</span>modules<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">)</span><span class="token punctuation">:</span>                nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'fan_out'</span><span class="token punctuation">,</span> nonlinearity<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> m<span class="token punctuation">.</span>bias <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                    nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>bias<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>m<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">)</span><span class="token punctuation">:</span>                nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">)</span>                nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>bias<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""测试模型"""</span><span class="token comment" spellcheck="true"># if __name__ == '__main__':</span><span class="token comment" spellcheck="true">#     input1 = torch.rand([224, 3, 224, 224])</span><span class="token comment" spellcheck="true">#     model_x = AlexNet()</span><span class="token comment" spellcheck="true">#     print(model_x)</span>    <span class="token comment" spellcheck="true"># output = AlexNet(input1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处的网络模型仅使用了一半的参数，即原 AlexNet 两块 GPU 中的一块。</p><h3 id="3-2-1-nn-Sequential-介绍"><a href="#3-2-1-nn-Sequential-介绍" class="headerlink" title="3.2.1 nn.Sequential 介绍"></a>3.2.1 nn.Sequential 介绍</h3><p>nn.Sequential 是 nn.Module 的容器，用于<strong>按顺序</strong>包装一组网络层，在模型复杂情况下，使用 nn.Sequential 方法对模块划分。除了 nn.Sequetial，还有 nn.ModuleList 和 nn.ModuleDict。</p><p><img src="https://img-blog.csdnimg.cn/656d92f257e241348bc649a9e5ae901d.png#pic_center" alt></p><h3 id="3-2-2-Tensor-展平"><a href="#3-2-2-Tensor-展平" class="headerlink" title="3.2.2  Tensor 展平"></a>3.2.2  Tensor 展平</h3><p>直接使用 torch.flatten 方法展平张量</p><pre class="line-numbers language-python"><code class="language-python"> x <span class="token operator">=</span> torch<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>x<span class="token punctuation">,</span> start_dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 二维平坦</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-3-model-py"><a href="#3-3-model-py" class="headerlink" title="3.3 model.py"></a>3.3 model.py</h2><h3 id="3-3-1-导入包"><a href="#3-3-1-导入包" class="headerlink" title="3.3.1  导入包"></a>3.3.1  导入包</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""训练(CPU)"""</span><span class="token keyword">import</span> os<span class="token keyword">import</span> sys<span class="token keyword">import</span> json<span class="token keyword">import</span> time<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token punctuation">,</span> datasets<span class="token punctuation">,</span> utils<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm   <span class="token comment" spellcheck="true"># 显示进度条模块</span><span class="token keyword">from</span> model <span class="token keyword">import</span> AlexNet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-2-数据集预处理"><a href="#3-3-2-数据集预处理" class="headerlink" title="3.3.2 数据集预处理"></a>3.3.2 数据集预处理</h3><pre class="line-numbers language-python"><code class="language-python">    data_transform <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"train"</span><span class="token punctuation">:</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>                                    transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 随机裁剪, 再缩放为 224*224</span>                                    transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 水平随机翻转</span>                                    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"val"</span><span class="token punctuation">:</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>                                    transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 元组(224, 224)</span>                                    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3-加载数据集"><a href="#3-3-3-加载数据集" class="headerlink" title="3.3.3 加载数据集"></a>3.3.3 加载数据集</h3><h4 id="3-3-3-1-读取数据路径"><a href="#3-3-3-1-读取数据路径" class="headerlink" title="3.3.3.1 读取数据路径"></a>3.3.3.1 读取数据路径</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># data_root = os.path.abspath(os.path.join(os.getcwd(), "../..")) # 读取数据路径</span>data_root <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"./"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>image_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_root<span class="token punctuation">,</span> <span class="token string">"data_set"</span><span class="token punctuation">,</span> <span class="token string">"flower_data"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># image_path = data_root + "/data_set/flower_data/"</span><span class="token keyword">assert</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} path does not exist."</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处相比于 UP 主教程，修改了读取路径。</p><h4 id="3-3-3-2-加载训练集"><a href="#3-3-3-2-加载训练集" class="headerlink" title="3.3.3.2 加载训练集"></a>3.3.3.2 加载训练集</h4><pre class="line-numbers language-python"><code class="language-python"> train_dataset <span class="token operator">=</span> datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>root<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> <span class="token string">"train"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                         transform<span class="token operator">=</span>data_transform<span class="token punctuation">[</span><span class="token string">"train"</span><span class="token punctuation">]</span>                                         <span class="token punctuation">)</span> train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span>                                               batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span>                                               shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                               num_workers<span class="token operator">=</span>nw                                               <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-3-加载验证集"><a href="#3-3-3-3-加载验证集" class="headerlink" title="3.3.3.3 加载验证集"></a>3.3.3.3 加载验证集</h4><pre class="line-numbers language-python"><code class="language-python">val_dataset <span class="token operator">=</span> datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>root<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>data_transform<span class="token punctuation">[</span><span class="token string">"val"</span><span class="token punctuation">]</span>                                       <span class="token punctuation">)</span>val_num <span class="token operator">=</span> len<span class="token punctuation">(</span>val_dataset<span class="token punctuation">)</span>val_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>val_dataset<span class="token punctuation">,</span>                                             batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>                                             shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                             num_workers<span class="token operator">=</span>nw                                             <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-4-保存数据索引"><a href="#3-3-3-4-保存数据索引" class="headerlink" title="3.3.3.4 保存数据索引"></a>3.3.3.4 保存数据索引</h4><pre class="line-numbers language-python"><code class="language-python">flower_list <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>class_to_idx    cla_dict <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> flower_list<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    json_str <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>cla_dict<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"calss_indices.json"</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> json_file<span class="token punctuation">:</span>        json_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>json_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4-训练过程"><a href="#3-3-4-训练过程" class="headerlink" title="3.3.4 训练过程"></a>3.3.4 训练过程</h3><pre class="line-numbers language-python"><code class="language-python">net <span class="token operator">=</span> AlexNet<span class="token punctuation">(</span>num_classes<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> init_weights<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 实例化网络(5分类)</span>    <span class="token comment" spellcheck="true"># net.to(device)</span>    net<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 直接指定 cpu</span>    loss_function <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 交叉熵损失</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.0002</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 优化器(训练参数, 学习率)</span>    epochs <span class="token operator">=</span> <span class="token number">10</span>     <span class="token comment" spellcheck="true"># 训练轮数</span>    save_path <span class="token operator">=</span> <span class="token string">"./AlexNet.pth"</span>    best_accuracy <span class="token operator">=</span> <span class="token number">0.0</span>    train_steps <span class="token operator">=</span> len<span class="token punctuation">(</span>train_loader<span class="token punctuation">)</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        net<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 开启Dropout</span>        running_loss <span class="token operator">=</span> <span class="token number">0.0</span>        train_bar <span class="token operator">=</span> tqdm<span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 设置进度条图标</span>        <span class="token keyword">for</span> step<span class="token punctuation">,</span> data <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_bar<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 遍历训练集,</span>            images<span class="token punctuation">,</span> labels <span class="token operator">=</span> data   <span class="token comment" spellcheck="true"># 获取训练集图像和标签</span>            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 清除历史梯度</span>            outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>images<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 正向传播</span>            loss <span class="token operator">=</span> loss_function<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 计算损失值</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 方向传播</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 更新优化器参数</span>            running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            train_bar<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">"train epoch [{}/{}] loss:{:.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                                                                      epochs<span class="token punctuation">,</span>                                                                      loss                                                                      <span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 验证</span>        net<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 关闭Dropout</span>        acc <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            val_bar <span class="token operator">=</span> tqdm<span class="token punctuation">(</span>val_loader<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span>            <span class="token keyword">for</span> val_data <span class="token keyword">in</span> val_bar<span class="token punctuation">:</span>                val_images<span class="token punctuation">,</span> val_labels <span class="token operator">=</span> val_data                outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>val_images<span class="token punctuation">)</span>                predict_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>max<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                acc <span class="token operator">+=</span> torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_y<span class="token punctuation">,</span> val_labels<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        val_accuracy <span class="token operator">=</span> acc <span class="token operator">/</span> val_num        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[epoch %d ] train_loss: %3f    val_accurancy: %3f"</span> <span class="token operator">%</span>              <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span> train_steps<span class="token punctuation">,</span> val_accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> val_accuracy <span class="token operator">></span> best_accuracy<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 保存准确率最高的</span>            best_accuracy <span class="token operator">=</span> val_accuracy            torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> save_path<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Finshed Training."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>训练过程可视化信息输出：</p><p><img src="https://img-blog.csdnimg.cn/fb6dcf0ecd424d6bb91480e680524068.png#pic_center" alt><br><strong>GPU 训练代码：</strong> 仅在 CPU 训练的基础上做了数据转换处理。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""训练(GPU)"""</span><span class="token keyword">import</span> os<span class="token keyword">import</span> sys<span class="token keyword">import</span> json<span class="token keyword">import</span> time<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token punctuation">,</span> datasets<span class="token punctuation">,</span> utils<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">from</span> model <span class="token keyword">import</span> AlexNet<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"use device is {device}"</span><span class="token punctuation">)</span>    data_transform <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"train"</span><span class="token punctuation">:</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>                                    transforms<span class="token punctuation">.</span>RandomResizedCrop<span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"val"</span><span class="token punctuation">:</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>                                    transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># data_root = os.path.abspath(os.path.join(os.getcwd(), "../..")) # 读取数据路径</span>    data_root <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"./"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    image_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>data_root<span class="token punctuation">,</span> <span class="token string">"data_set"</span><span class="token punctuation">,</span> <span class="token string">"flower_data"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># image_path = data_root + "/data_set/flower_data/"</span>    <span class="token keyword">assert</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} path does not exist."</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span>    train_dataset <span class="token operator">=</span> datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>root<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> <span class="token string">"train"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                         transform<span class="token operator">=</span>data_transform<span class="token punctuation">[</span><span class="token string">"train"</span><span class="token punctuation">]</span>                                         <span class="token punctuation">)</span>    train_num <span class="token operator">=</span> len<span class="token punctuation">(</span>train_dataset<span class="token punctuation">)</span>    flower_list <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>class_to_idx    cla_dict <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> flower_list<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    json_str <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>cla_dict<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"calss_indices.json"</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> json_file<span class="token punctuation">:</span>        json_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>json_str<span class="token punctuation">)</span>    batch_size <span class="token operator">=</span> <span class="token number">32</span>    nw <span class="token operator">=</span> min<span class="token punctuation">(</span><span class="token punctuation">[</span>os<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size <span class="token keyword">if</span> batch_size <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 线程数计算</span>    nw <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Using {nw} dataloader workers every process."</span><span class="token punctuation">)</span>    train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span>                                               batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span>                                               shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                               num_workers<span class="token operator">=</span>nw                                               <span class="token punctuation">)</span>    val_dataset <span class="token operator">=</span> datasets<span class="token punctuation">.</span>ImageFolder<span class="token punctuation">(</span>root<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>data_transform<span class="token punctuation">[</span><span class="token string">"val"</span><span class="token punctuation">]</span>                                       <span class="token punctuation">)</span>    val_num <span class="token operator">=</span> len<span class="token punctuation">(</span>val_dataset<span class="token punctuation">)</span>    val_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>val_dataset<span class="token punctuation">,</span>                                             batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>                                             shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                             num_workers<span class="token operator">=</span>nw                                             <span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Using {train_num} images for training, {val_num} images for validation."</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># test_data_iter = iter(val_loader)</span>    <span class="token comment" spellcheck="true"># test_image, test_label = next(test_data_iter)</span>    <span class="token triple-quoted-string string">""" 测试数据集图片"""</span>    <span class="token comment" spellcheck="true"># def imshow(img):</span>    <span class="token comment" spellcheck="true">#     img = img / 2 + 0.5</span>    <span class="token comment" spellcheck="true">#     np_img = img.numpy()</span>    <span class="token comment" spellcheck="true">#     plt.imshow(np.transpose(np_img, (1, 2, 0)))</span>    <span class="token comment" spellcheck="true">#     plt.show()</span>    <span class="token comment" spellcheck="true"># print(' '.join('%5s' % cla_dict[test_label[j].item()] for j in range(4)))</span>    <span class="token comment" spellcheck="true"># imshow(utils.make_grid(test_image))</span>    net <span class="token operator">=</span> AlexNet<span class="token punctuation">(</span>num_classes<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> init_weights<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    loss_function <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.0002</span><span class="token punctuation">)</span>    epochs <span class="token operator">=</span> <span class="token number">10</span>    save_path <span class="token operator">=</span> <span class="token string">"./AlexNet.pth"</span>    best_accuracy <span class="token operator">=</span> <span class="token number">0.0</span>    train_steps <span class="token operator">=</span> len<span class="token punctuation">(</span>train_loader<span class="token punctuation">)</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        net<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>        running_loss <span class="token operator">=</span> <span class="token number">0.0</span>        train_bar <span class="token operator">=</span> tqdm<span class="token punctuation">(</span>train_loader<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span>        <span class="token keyword">for</span> step<span class="token punctuation">,</span> data <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_bar<span class="token punctuation">)</span><span class="token punctuation">:</span>            images<span class="token punctuation">,</span> labels <span class="token operator">=</span> data            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>            loss <span class="token operator">=</span> loss_function<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>            running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            train_bar<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">"train epoch [{}/{}] loss:{:.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                                                                      epochs<span class="token punctuation">,</span>                                                                      loss                                                                      <span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 验证</span>        net<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>        acc <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            val_bar <span class="token operator">=</span> tqdm<span class="token punctuation">(</span>val_loader<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span>            <span class="token keyword">for</span> val_data <span class="token keyword">in</span> val_bar<span class="token punctuation">:</span>                val_images<span class="token punctuation">,</span> val_labels <span class="token operator">=</span> val_data                outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>val_images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>                predict_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>max<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                acc <span class="token operator">+=</span> torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_y<span class="token punctuation">,</span> val_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>        val_accuracy <span class="token operator">=</span> acc <span class="token operator">/</span> val_num        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[epoch %d ] train_loss: %3f    val_accurancy: %3f"</span> <span class="token operator">%</span>              <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span> train_steps<span class="token punctuation">,</span> val_accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> val_accuracy <span class="token operator">></span> best_accuracy<span class="token punctuation">:</span>            best_accuracy <span class="token operator">=</span> val_accuracy            torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>net<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> save_path<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Finshed Training."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-5-结果预测"><a href="#3-3-5-结果预测" class="headerlink" title="3.3.5 结果预测"></a>3.3.5 结果预测</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""预测"""</span><span class="token triple-quoted-string string">"""预测"""</span><span class="token keyword">import</span> os<span class="token keyword">import</span> json<span class="token keyword">import</span> torch<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> model <span class="token keyword">import</span> AlexNet<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span>    data_transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>        transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>    image_path <span class="token operator">=</span> <span class="token string">"./sunflowers01.jpg"</span>    img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    img <span class="token operator">=</span> data_transform<span class="token punctuation">(</span>img<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># [N, C H, W]</span>    img <span class="token operator">=</span> torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>img<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 维度扩展</span>    <span class="token comment" spellcheck="true"># print(f"img={img}")</span>    json_path <span class="token operator">=</span> <span class="token string">"./calss_indices.json"</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span>json_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        class_indict <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># model = AlexNet(num_classes=5).to(device)   # GPU</span>    model <span class="token operator">=</span> AlexNet<span class="token punctuation">(</span>num_classes<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># CPU</span>    weights_path <span class="token operator">=</span> <span class="token string">"./AlexNet.pth"</span>    model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>weights_path<span class="token punctuation">)</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 关闭 Dorpout</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># output = torch.squeeze(model(img.to(device))).cpu()   #GPU</span>        output <span class="token operator">=</span> torch<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>model<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 维度压缩</span>        predict <span class="token operator">=</span> torch<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>output<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        predict_cla <span class="token operator">=</span> torch<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>predict<span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>        print_res <span class="token operator">=</span> <span class="token string">"class: {}  prob: {:.3}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>class_indict<span class="token punctuation">[</span>str<span class="token punctuation">(</span>predict_cla<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                    predict<span class="token punctuation">[</span>predict_cla<span class="token punctuation">]</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>print_res<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># for i in range(len(predict)):</span>        <span class="token comment" spellcheck="true">#     print("class: {}  prob: {:.3}".format(class_indict[str(predict_cla)],</span>        <span class="token comment" spellcheck="true">#                                             predict[predict_cla].numpy()))</span>        plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预测结果如下：</p><p><img src="https://img-blog.csdnimg.cn/d5c7d1622c404b7ba5f0112dd96bf93a.png#pic_center" alt></p><p>输入向日葵，预测准确率为 1.0 。</p><hr><p><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></p><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><hr><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://blog.csdn.net/m0_37867091/article/details/107150142" target="_blank" rel="noopener">pytorch图像分类篇：3.搭建AlexNet并训练花分类数据集</a></li><li><a href="https://www.bilibili.com/video/BV1W7411T7qc/?spm_id_from=333.999.0.0&vd_source=103efe685ad4c1216c5d837f7dd7d25c" target="_blank" rel="noopener">B站UP主——3.2 使用pytorch搭建AlexNet并训练花分类数据集</a></li><li><a href="https://blog.51cto.com/u_4029519/5424126" target="_blank" rel="noopener">TensorFlow2学习十三、实现AlexNet</a></li><li><a href="https://yey.world/2020/12/15/Pytorch-11/" target="_blank" rel="noopener">PyTorch 11：模型容器与 AlexNet 构建</a></li><li><a href="https://yey.world/2020/12/14/Pytorch-10/" target="_blank" rel="noopener">PyTorch 10：模型创建步骤与 nn.Module</a></li><li><a href="https://cs231n.github.io/assets/conv-demo/index.html" target="_blank" rel="noopener">卷积——动图演示</a></li><li><a href="https://www.runoob.com/python3/python3-os-path.html" target="_blank" rel="noopener">Python3 os.path() 模块</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> DeepLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> Pytorch </tag>
            
            <tag> AlexNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOS管（三极管）——一些常用的硬件设计电路分析</title>
      <link href="/2020/08/21/mos-guan-san-ji-guan-yi-xie-chang-yong-de-ying-jian-she-ji-dian-lu-fen-xi/"/>
      <url>/2020/08/21/mos-guan-san-ji-guan-yi-xie-chang-yong-de-ying-jian-she-ji-dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>芯片的集成度虽然越来越高，但是整个电路功能的实现，还是离不开分离器件的搭配，本文就针对笔者在实际工作中的关于 MOS 管（三极管）的应用做一些整理。</p><p>本文所介绍的功能，使用三极管也是可以的，但是实际应用中，多使用 MOS 管，故本文多以 MOS 管进行说明。</p><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h2><h3 id="2-1-NMOS-开关控制"><a href="#2-1-NMOS-开关控制" class="headerlink" title="2.1 NMOS 开关控制"></a>2.1 NMOS 开关控制</h3><p><img src="https://img-blog.csdnimg.cn/2020070923233216.png" alt><br>如图，通过 NMOS 的开关作用，完成对 LED 的亮灭控制。此时 MOS 管工作于截止区和可变电阻区。</p><table><thead><tr><th>控制端</th><th>状态</th></tr></thead><tbody><tr><td>LED0 为高电平</td><td>点亮 LED</td></tr><tr><td>LED0 为低电平</td><td>LED熄灭</td></tr></tbody></table><p>对于 NMOS ，当 Vgs = Vg - Vs &gt; 0 时，NMOS 导通；当 Vgs = Vg - Vs &lt; 0 时，NMOS 断开。</p><h3 id="2-2-PMOS-电源控制"><a href="#2-2-PMOS-电源控制" class="headerlink" title="2.2 PMOS 电源控制"></a>2.2 PMOS 电源控制</h3><h4 id="2-2-1-IO-控制"><a href="#2-2-1-IO-控制" class="headerlink" title="2.2.1 IO 控制"></a>2.2.1 IO 控制</h4><p><img src="https://img-blog.csdnimg.cn/20200709233723876.png" alt></p><p>PMOS 在整个电路系统中，其中某一部分的电路上电通过控制中可以方便用于通断控制。<strong>上图的电路中，使用时需要注意的一点是 VCC_IN 与控制断的电平 PWR_CON 要处于同一标准（eg：VCC_IN = 3.3V；PWR_CON 高电平 = 3.3V）</strong>。</p><table><thead><tr><th>控制端</th><th>状态</th></tr></thead><tbody><tr><td>PWR_CON 为高电平</td><td>PMOS 断开，VCC_OUT  无电压输出</td></tr><tr><td>PWR_CON 为低电平</td><td>PMOS 导通，VCC_OUT  有电压输出，VCC_IN ≈ VCC_OUT</td></tr></tbody></table><p>对于 PMOS ，当 Vgs = Vg - Vs &lt; 0 时，PMOS 导通；当 Vgs = Vg - Vs &gt; 0 时，PMOS 断开。</p><p>因为 MOS 管的导通压降是非常小的，所以在 Rds 之上的能量损耗是比较少的。</p><h4 id="2-2-2-NMOS-控制-PMOS"><a href="#2-2-2-NMOS-控制-PMOS" class="headerlink" title="2.2.2 NMOS 控制 PMOS"></a>2.2.2 NMOS 控制 PMOS</h4><p>进一步地，上图的电路可以扩展为下图，PMOS 的栅极通过 NMOS 来控制。</p><p><img src="https://img-blog.csdnimg.cn/20200709234818506.png" alt><br>拓展为此电路，针对 VCC_IN 与 PWR_CON 电压就没有强制的要求了。当 PWR_CON 为高电平的时候，NMOS 导通，PMOS 的栅极被拉低到低电平，PMOS 导通，VCC_OUT 有电压输出；反之，当 PWR_CON 为低电平时，NMOS 关断，从而使 PMOS 也断开，这样就完成了 VCC_IN 输出电压到 VCC_OUT 的控制。</p><h4 id="2-2-3-按键上电控制"><a href="#2-2-3-按键上电控制" class="headerlink" title="2.2.3 按键上电控制"></a>2.2.3 按键上电控制</h4><p><img src="https://img-blog.csdnimg.cn/2020071000002557.png" alt></p><p>上图的电路，就可以完成所谓的按键开机的功能。</p><p>（1）按下 K1 按键，PMOS 的栅极被拉低，Vgs &lt; 0，PMOS 导通，VCC_OUT 有电压输出；</p><p>（2）VCC_OUT 有电压输出，按键按下时可完成对 MCU 的供电，然后软件端通过 MCU 的 GPIO 进而控制 NMOS 的栅极，即 PWR_CON 。先通过 KEY_DET 检测到按键动作，然后把 PWR_CON 设置为高电平，NMOS 导通，使得 PMOS 也导通，这时候抬起按键，VCC_OUT 一端也有电压稳定输出，就实现了按键上电开机的功能。</p><p>此电路的二极管，功能是防止电压反窜和 对MCU 的 GPIO 的保护。</p><p>功能流程：</p><p><img src="https://img-blog.csdnimg.cn/20200710000824405.png" alt></p><h3 id="2-3-反相（非门逻辑）"><a href="#2-3-反相（非门逻辑）" class="headerlink" title="2.3 反相（非门逻辑）"></a>2.3 反相（非门逻辑）</h3><p>如果电路中需要实现逻辑非的功能，可以采用 MOS 管（三极管）加上电阻来实现，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200710231654178.png" alt></p><table><thead><tr><th>控制端</th><th>状态</th></tr></thead><tbody><tr><td>INPUT 为高电平</td><td>OUTPUT 为低电平</td></tr><tr><td>INPUT 为低电平</td><td>OUTPUT 为高电平</td></tr></tbody></table><p>通过一个 MOS 管（三极管）加上两个电阻，就可以实现非门的逻辑。</p><p>具体的应用可参考本文：<a href="https://blog.csdn.net/wwt18811707971/article/details/89190625" target="_blank" rel="noopener">再学 SPI ——（一）SPI片选信号</a></p><h3 id="2-4-电池防反接功能"><a href="#2-4-电池防反接功能" class="headerlink" title="2.4 电池防反接功能"></a>2.4 电池防反接功能</h3><p>在大多数的电池防反接电路中，常选择压降小的二极管（如：肖特基二极管）来完成，但是针对如 3.7V 锂电池的应用场景，肖特基约为 0.2V 的压降天然的造成了电池容量的浪费，而 MOS 管导通的低压降（Vds）就有很大的优势了。</p><p><img src="https://img-blog.csdnimg.cn/20200721215826886.png" alt></p><p>如上图所示，PMOS 在此处的作用就是防止 VBUS 存在时，LDO Vin 端的电压反窜到电池上。</p><p>原理分析：</p><p>（1）当 USB VBUS 存在时，PMOS 的栅极电压 Vg = 5V，源极电压 Vs = 3.7V（假设此时的电池电压为 3.7V），Vgs = 5 - 3.7 = 1.3V（大于0），此时 PMOS 关断，就起到了防止 Vin 端电压反窜的作用；</p><p>（2）当 USB VBUS 不存在时，PMOS 的栅极通过 10K 的电阻下拉到 GND，因此栅极电压 Vg = 0V，源极电压 Vs = 3.7V（假设此时的电池电压为 3.7V），电池通过 PMOS 自身的寄生二极管使得 Vs = 3.7V，所以 PMOS 的导通电压 Vgs = 0 - 3.7 = -3.7V，PMOS 导通，这样就完成了电池电压到 Vin 端的输入。</p><p>上图的 LDO 电路，只要使能端 LDO_CON 给一个开启信号，输出端 V_3V3 就可以稳定输出 3.3V，C3、C4 为 LDO 的输入输出电容，一般大于 1uF（具体参考数据手册取值）。</p><p>具体的应用可参考本文：<a href="https://blog.csdn.net/wwt18811707971/article/details/80232617" target="_blank" rel="noopener">电源防反接小结</a></p><h3 id="2-5-IO通信双向切换"><a href="#2-5-IO通信双向切换" class="headerlink" title="2.5 IO通信双向切换"></a>2.5 IO通信双向切换</h3><p>在一些设备中，如果两个通过 IO 连接的器件，某一时刻，一个处于休眠，一个处于掉电，这时候就会导致休眠的器件向掉电的器件灌入电流，为了完全杜绝此状态下的电路窜入，可采取如下电路的设计（比如：I2C 的 SDA 信号）</p><p><img src="https://img-blog.csdnimg.cn/20200710234822821.png" alt></p><p><strong>原理分析：</strong></p><table><thead><tr><th>M_DATA</th><th>S_DATA</th><th>导通状态</th><th>方向</th></tr></thead><tbody><tr><td>高电平</td><td>高电平</td><td>Vgs = 0V，MOS 管截止</td><td>M_DATA—&gt;S_DATA</td></tr><tr><td>低电平</td><td>低电平</td><td>Vgs &gt; 0V，MOS 管导通</td><td>M_DATA—&gt;S_DATA</td></tr></tbody></table><table><thead><tr><th>S_DATA</th><th>M_DATA</th><th>导通状态</th><th>方向</th></tr></thead><tbody><tr><td>高电平</td><td>高电平</td><td>M_DATA 通过上拉电阻 R9 设置成高电平，MOS 管截止</td><td>S_DATA—&gt;M_DATA</td></tr><tr><td>低电平</td><td>低电平</td><td>S_DATA = 0，NMOS 的寄生二极管导通，进而使得 Vgs &gt; 0，MOS 管导通，M_DATA 为低电平</td><td>S_DATA—&gt;M_DATA</td></tr></tbody></table><p>如上面两个方向的表格分析，这样通过 NMOS 就完成了一个 IO 双向通信的控制。（只能选择 NMOS，不可选择 PMOS，原因读着可以自行分析一下）</p><h3 id="2-6-3-3V-与-5V-的电平转换"><a href="#2-6-3-3V-与-5V-的电平转换" class="headerlink" title="2.6 3.3V 与 5V 的电平转换"></a>2.6 3.3V 与 5V 的电平转换</h3><p>（1） MOS 实现：</p><p>在实际的应用中，常会遇到通信的两个芯片之间的电平不匹配的问题，这时候就需要通过外部的电路来完成电平匹配的工作（如：MCU 的电平为 3.3V，而外设的电平为 5V）。</p><p><img src="https://img-blog.csdnimg.cn/20200711001539440.png" alt></p><p><strong>原理分析：</strong></p><table><thead><tr><th>3V3_DATA</th><th>5V_DATA</th><th>导通状态</th><th>方向</th></tr></thead><tbody><tr><td>高电平</td><td>高电平</td><td>Vgs = 0V，MOS 管截止</td><td>3V3_DATA—&gt;5V_DATA</td></tr><tr><td>低电平</td><td>低电平</td><td>Vgs &gt; 0V，MOS 管导通</td><td>3V3_DATA—&gt;5V_DATA</td></tr></tbody></table><p>通过 3.3V 端高低电平的变化，使得 NMOS 对应开关，就完成了 3.3V 电平到 5V 电平的转换。</p><table><thead><tr><th>5V_DATA</th><th>3V3_DATA</th><th>导通状态</th><th>方向</th></tr></thead><tbody><tr><td>高电平</td><td>高电平</td><td>MOS 管截止，3V3_DATA 通过上拉电阻 R12 设置成高电平</td><td>5V_DATA—&gt;3V3_DATA</td></tr><tr><td>低电平</td><td>低电平</td><td>5V_DATA= 0，NMOS 的寄生二极管导通，进而使得 Vgs &gt; 0，MOS 管导通，M_DATA 为低电平</td><td>5V_DATA—&gt;3V3_DATA</td></tr></tbody></table><p>反之，也完成了对 5V 设备的数据的读取。</p><p>注：此电路用三极管也可以实现同样的功能，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200711005859391.png" alt></p><p>（2） 两级 NPN 实现：</p><p>如下图所示，3.3V 与 5V 之间的电平转换，也可以通过两级的 NPN 三极管来实现。</p><p><img src="https://img-blog.csdnimg.cn/20200711004027250.png" alt><br><strong>原理分析：</strong></p><table><thead><tr><th>3V3_DATA</th><th>5V_DATA</th><th>导通状态</th><th>方向</th></tr></thead><tbody><tr><td>高电平</td><td>高电平</td><td>Q10 导通，Q9 截止，5V_DATA 端得到 5V 的高电平</td><td>3V3_DATA—&gt;5V_DATA</td></tr><tr><td>低电平</td><td>低电平</td><td>Q10 截止，Q9 导通，5V_DATA 端得到 低电平</td><td>3V3_DATA—&gt;5V_DATA</td></tr></tbody></table><hr><p>以上为一些常用的 MOS 管的实际应用电路，部分笔者已在实际中进行了验证，如有不足之处，欢迎指正。</p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hardware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mos管 </tag>
            
            <tag> 电路设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Allegro专题【6】——Allegro 使用小记</title>
      <link href="/2020/08/08/allegro-zhuan-ti-6-allegro-shi-yong-xiao-ji/"/>
      <url>/2020/08/08/allegro-zhuan-ti-6-allegro-shi-yong-xiao-ji/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-推挤时，45-度走线推入焊盘中"><a href="#1-推挤时，45-度走线推入焊盘中" class="headerlink" title="1. 推挤时，45 度走线推入焊盘中"></a>1. 推挤时，45 度走线推入焊盘中</h2><p>走线状态下，去掉下图所选之前的 “√”</p><p><img src="https://img-blog.csdnimg.cn/2020071322492694.PNG" alt></p><h2 id="2-推挤走线"><a href="#2-推挤走线" class="headerlink" title="2. 推挤走线"></a>2. 推挤走线</h2><p>命令：slide</p><p><img src="https://img-blog.csdnimg.cn/20200713225557774.PNG" alt></p><h2 id="3-Z-copy-命令"><a href="#3-Z-copy-命令" class="headerlink" title="3. Z-copy 命令"></a>3. Z-copy 命令</h2><p>Z-copy 用于 PCB 导入板框后，禁止布线层的生成（同时也是 PCB 覆铜时区域），操作方法如下：</p><p>（1）先确定板框层（board geometry outline），如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200805095503466.png" alt></p><p>（2）选择 Z-copy 命令，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200805100556814.png" alt></p><p>参数设置如下，设置完成后选择板框层即可生成布线区域》</p><p><img src="https://img-blog.csdnimg.cn/20200805100955252.png" alt></p><h2 id="4-过孔"><a href="#4-过孔" class="headerlink" title="4. 过孔"></a>4. 过孔</h2><p>需要先使用 PAD Designer 制作过孔，然后在添加到 allegro 中。制作方式同通孔焊盘，只是过孔无需阻焊层和钢网层。</p><h2 id="5-测量距离显示两种单位"><a href="#5-测量距离显示两种单位" class="headerlink" title="5. 测量距离显示两种单位"></a>5. 测量距离显示两种单位</h2><p>（1）先确定默认使用的是什么单位，这里默认的是英制（mil），如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020080619350532.png" alt></p><p>（2）增加公制测量距离（mm），如下图，然后确定。</p><p><img src="https://img-blog.csdnimg.cn/20200806193922112.png" alt></p><p>（3）这样设置之后就可以在测量距离的时候看到两种单位的距离了。</p><p><img src="https://img-blog.csdnimg.cn/20200806194050141.png" alt></p><h2 id="6-添加等长的时候，添加-match-group-后，actual-和margin-数据无显示"><a href="#6-添加等长的时候，添加-match-group-后，actual-和margin-数据无显示" class="headerlink" title="6.  添加等长的时候，添加 match group 后，actual 和margin 数据无显示"></a>6.  添加等长的时候，添加 match group 后，actual 和margin 数据无显示</h2><p><strong>现象：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200808105919418.png" alt></p><p><strong>解决：</strong></p><p>（1）如下图，找到对应的选项。</p><p><img src="https://img-blog.csdnimg.cn/20200808110121366.PNG" alt></p><p>（2）打开下图所示的选项，然后确定。再返回规则约束选项，重新分析一下即可显示出 actual 和 margin 的数值。【如果这样操作之后还是不能够显示，可在 setup ——&gt; constraints ——&gt; Modes 的 Electrical Options 里面勾选延时分析选项】</p><p><img src="https://img-blog.csdnimg.cn/20200808110531893.png" alt></p><p>（3）调整设置之后的显示结果如下，就显示出实际的走线长度和还欠缺走线的长度。</p><p><img src="https://img-blog.csdnimg.cn/20200808110702990.png" alt></p><h2 id="7-等长规则的添加"><a href="#7-等长规则的添加" class="headerlink" title="7. 等长规则的添加"></a>7. 等长规则的添加</h2><h3 id="7-1-点对点-match-group-直接添加"><a href="#7-1-点对点-match-group-直接添加" class="headerlink" title="7.1 点对点 match group 直接添加"></a>7.1 点对点 match group 直接添加</h3><p>本方式适用于两个 IC 之间通过走线连接的拓扑结构，在规则管理器中选择同一组走线，然后添加到 Match group 即可，在电机 analysis 之后就可以看到同一组的走线已经添加完成，如下图，选择同一组走线，添加到 match group。</p><p><img src="https://img-blog.csdnimg.cn/20200808141122670.PNG" alt></p><p>添加完成后，如下图，就可以看到等长的信息了。</p><p><img src="https://img-blog.csdnimg.cn/20200808141352922.PNG" alt></p><h3 id="7-2-模型添加"><a href="#7-2-模型添加" class="headerlink" title="7.2 模型添加"></a>7.2 模型添加</h3><p>此方式常用于两个 IC 之间串联电阻的拓扑，当然直接走线连接也是可以的。</p><p>（1）选中等长线中的一根线，然后建立模型，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200808141643189.PNG" alt></p><p>（2）建立模型后进入如下的界面</p><p><img src="https://img-blog.csdnimg.cn/20200808141829782.PNG" alt></p><p>（3）如下图，进入具体的参数设置。</p><p><img src="https://img-blog.csdnimg.cn/20200808142102290.png" alt></p><p>（4）参数设置如下，此处需要结合实际的应用调整。</p><p><img src="https://img-blog.csdnimg.cn/2020080814230413.png" alt></p><p>设置完参数，点击 add。</p><p><img src="https://img-blog.csdnimg.cn/20200808143609357.png" alt></p><p>（5）确定设置之后，更新规则到约束管理器，点击下图操作：</p><p><img src="https://img-blog.csdnimg.cn/20200808142551437.PNG" alt></p><p>如下图，约束管理器里面已经可以看到第一根走线的规则添加成功了。</p><p><img src="https://img-blog.csdnimg.cn/20200808143843524.png" alt></p><p>然后把其他需要同组等长约束的走线一起添加到第一根线的规则上，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808144117318.png" alt></p><h2 id="8-光绘文件配置"><a href="#8-光绘文件配置" class="headerlink" title="8. 光绘文件配置"></a>8. 光绘文件配置</h2><p>需要添加的文件，下面以一个 4 层板为例。</p><p>（1）<strong>电气层——顶层示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200808170828804.PNG" alt></p><table><thead><tr><th align="center">板层</th><th align="center">文件</th></tr></thead><tbody><tr><td align="center">TOP</td><td align="center">ETCH /PIN /VIA CLASS /OUTLINE</td></tr><tr><td align="center">GND</td><td align="center">ETCH /PIN /VIA CLASS /OUTLINE</td></tr><tr><td align="center">PWR</td><td align="center">ETCH /PIN /VIA CLASS /OUTLINE</td></tr><tr><td align="center">BOTTOM</td><td align="center">ETCH /PIN /VIA CLASS /OUTLINE</td></tr></tbody></table><p>（2）<strong>丝印层——顶层示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200808172026452.png" alt></p><table><thead><tr><th align="center">CLASS</th><th align="center">文件</th></tr></thead><tbody><tr><td align="center">Board geometry</td><td align="center">SILKSCREEN</td></tr><tr><td align="center">Package geometry</td><td align="center">SILKSCREEN</td></tr><tr><td align="center">Refdes</td><td align="center">SILKSCREENE</td></tr></tbody></table><p>（3）<strong>阻焊层——顶层示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200808173018150.png" alt></p><table><thead><tr><th align="center">CLASS</th><th align="center">文件</th></tr></thead><tbody><tr><td align="center">Board geometry</td><td align="center">SOLDMASK_TOP</td></tr><tr><td align="center">Package geometry</td><td align="center">SOLDMASK_TOP</td></tr><tr><td align="center">PIN</td><td align="center">SOLDMASK_TOP</td></tr><tr><td align="center">VIA CLASS</td><td align="center">SOLDMASK_TOP</td></tr></tbody></table><p>（4）<strong>钢网层——顶层示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/202008081738244.png" alt></p><table><thead><tr><th align="center">CLASS</th><th align="center">文件</th></tr></thead><tbody><tr><td align="center">Package geometry</td><td align="center">PASTMASK_TOP</td></tr><tr><td align="center">PIN</td><td align="center">PASTMASK_TOP</td></tr></tbody></table><p>（5）<strong>钻孔：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200808181329856.png" alt></p><table><thead><tr><th align="center">CLASS</th><th align="center">文件</th></tr></thead><tbody><tr><td align="center">Manufacturing</td><td align="center">NCLEGEND-1-4</td></tr><tr><td align="center">Manufacturing</td><td align="center">NCDRILL_LEGEND</td></tr><tr><td align="center">Manufacturing</td><td align="center">NCDRILL_FIGURE</td></tr></tbody></table><p>NCLEGEND-1-4 需要在添加之前生成，操作如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808181652924.PNG" alt></p><p>PCB 上面的表格即为钻孔参数【注：对于同一类孔径的钻孔，在生成文件之前可进行合并成同一类】</p><p>至此，配置输出的印刷板的光绘文件就全部生成了，4 层板共计 11 项，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808182234280.png" alt></p><p>为了方便查看装配文件，再整理顶层，底层的装配文件，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808182912259.png" alt></p><h2 id="9-光绘文件输出"><a href="#9-光绘文件输出" class="headerlink" title="9. 光绘文件输出"></a>9. 光绘文件输出</h2><h3 id="9-1-参数设置"><a href="#9-1-参数设置" class="headerlink" title="9.1 参数设置"></a>9.1 参数设置</h3><p>（1）输出的类型、精度、单位等参数设置。</p><p><img src="https://img-blog.csdnimg.cn/20200808184738814.png" alt></p><p>（2）输出正片（负片）、0 线宽的等参数设置。</p><p><img src="https://img-blog.csdnimg.cn/20200808185054775.png" alt></p><h3 id="9-2-输出文件"><a href="#9-2-输出文件" class="headerlink" title="9.2 输出文件"></a>9.2 输出文件</h3><p><img src="https://img-blog.csdnimg.cn/20200808191140670.png" alt></p><p>弹出的提示信息若无 error 提示，则表示输出光绘成功。</p><h3 id="9-2-输出其他文件"><a href="#9-2-输出其他文件" class="headerlink" title="9.2 输出其他文件"></a>9.2 输出其他文件</h3><p>（1）器件坐标文件：file ——&gt; export ——&gt; placement… 默认输出即可；</p><p>（2）IPC 文件：file ——&gt; export ——&gt; IPC-D-356… 默认输出即可</p><p>（3）pdf 装配文件：file ——&gt; export ——&gt; PDF… 参数配置如下：</p><p><img src="https://img-blog.csdnimg.cn/20200808191915238.png" alt></p><p><strong>需要注意的两点：</strong> </p><p>1）输出的时候，为了镜像过来与正常的板子一致，在光绘输出配置里需要勾选：Film mirrored；</p><p>2）因为我们在设计封装的时候，在装配层也是放置了文字的，而我们输出的时候并不需要这些文件，故输出 PDF 文件之前需删除装配层的文字。</p><p>到此基本就完成了 PCB 文件的输出了。</p><hr><p>今天先到这——20200808</p><hr><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hardware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
            <tag> Allegro </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号完整性专题【1】——电源完整性（PI）</title>
      <link href="/2020/07/30/xin-hao-wan-zheng-xing-zhuan-ti-1-dian-yuan-wan-zheng-xing-pi/"/>
      <url>/2020/07/30/xin-hao-wan-zheng-xing-zhuan-ti-1-dian-yuan-wan-zheng-xing-pi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>电源完整性：</strong> 如何保证电源分配系统（Power Distribution Network—— PDN）满足负载芯片对电源的要求，即为电源完整性。</p><p>解释一下，即电源调整系统为各部分电路提供稳定正确的工作电压，使系统的各部分能在负载电流发生变化时依然能够保持稳定。能够对系统因状态变化或者受到某些影响（比如：电压波动、串扰、反射、辐射、噪声等）进行有效抑制。</p><p><strong>PDN 系统的作用：</strong> </p><p>（1）为负载提供干净的供电电压；</p><p>（2）为信号提供低噪声的参考路径（返回路径）；</p><p>（3）减轻电磁干扰（EMI）问题。</p><p>理想的电源系统的阻抗为 0 ，但是实际中是存在各种各样额噪声，电路是在一定程度的噪声容限下工作的，如果电源的噪声超出了系统允许的范围，就有可能导致系统不能按照既定的方式正常运行。</p><p><img src="https://img-blog.csdnimg.cn/20200729140101190.png" alt></p><p>当芯片内部的晶体管的翻转的时候需要从 PDN 系统汲取电流，只要芯片端的电源分配网络的输入阻抗足够低，那么在这个过程中的压降也会降低，保持芯片电源的稳定（在噪声容限内波动不影响芯片的正常工作）</p><hr><h2 id="2-造成电源完整性问题的原因"><a href="#2-造成电源完整性问题的原因" class="headerlink" title="2. 造成电源完整性问题的原因"></a>2. 造成电源完整性问题的原因</h2><p>先分析一下影响电源完整性的原因，找到了病根，才好对症下药。</p><p>随着芯片的开关速度越来越快（上升时间越来越小），芯片内的开关管不可能同步完成转换，当一部分的晶体管已经完成稳定转换，而另一部分则还在转换之中，状态的不同步就造成电源早上在芯片内部传递，可能导致某些不定态的晶体管输出状态错误。</p><p>芯片的开关速度不断提高，导致瞬态电流和功耗都随之增加。</p><p><strong>电源分配系统的噪声来源：</strong><br>|编号|原因|<br>|:—:|:—-:|<br>|1|电源稳压芯片自身的输出存在噪声，DC-DC 的输出纹波就比 LDO 大|<br>|2|电源的输出无法对负载电流的快速变化实时响应，造成电压跌落|<br>|3|电源路径和地回路都存在一定的阻抗，电流经供电回路不可避免的存在压降，瞬态电流的变化就造成负载电压的波动|<br>|4|高速信号通过过孔换层引起电源噪声|</p><hr><h2 id="3-PDN-系统"><a href="#3-PDN-系统" class="headerlink" title="3. PDN 系统"></a>3. PDN 系统</h2><p>电源分配网络包括：电压调整模块（Voltage Regulator Module）到电路板上各部分电源之间的互相连接，具体为电路板上的电源平面、地平面、连线、电缆、接口<br>、电容等。</p><p>PDN 系统模型如下图所示，从左往右依次是 PCB 的 PDN，芯片封装的 PDN。</p><p><img src="https://img-blog.csdnimg.cn/20200729143611778.png" alt></p><hr><h2 id="4-PDN-之-RLC"><a href="#4-PDN-之-RLC" class="headerlink" title="4. PDN 之 RLC"></a>4. PDN 之 RLC</h2><h3 id="4-1-电阻（R）"><a href="#4-1-电阻（R）" class="headerlink" title="4.1 电阻（R）"></a>4.1 电阻（R）</h3><p>电阻是表征导体对直流电流的阻碍作用。当回路中，一段导体有电流流过时，电阻的作用表现为电能转化为热能（I^2 R），在导体的两端产生一定的压降（U = IR）。电阻的大小与导体的材料，长度，横截面积，温度有关。</p><p><img src="https://img-blog.csdnimg.cn/20200729153926326.png" alt></p><p>电源分配系统上的电阻产生的损耗会导致电能转换为热能被丧失掉，同时温度的升高又对电路或一些器件造成影响，从而影响系统的稳定性和可靠性。如果某些部分电流持续增大甚至会导致该部分的电路烧毁。</p><p>下图为电阻在低频和高频下表现出来的特性：</p><p><img src="https://img-blog.csdnimg.cn/20200729163126565.png" alt></p><h3 id="4-2-电感（L）"><a href="#4-2-电感（L）" class="headerlink" title="4.2 电感（L）"></a>4.2 电感（L）</h3><p>电感是表征导体对交变电流阻碍作用的物理量。当导体中有电流流过时，会在导体的周围形成磁场。当电流变化时，周围的磁场也会发生变化，在导体的两端形成感应电动势，形成的感应电动势形成的电流反过来阻碍原有电流的变化。即电感是：通直流，阻交流。这样形成的电感称之为自感（L）。当两个支路距离比较近，两个支路之间的互相影响称之为互感（M）。</p><p><img src="https://img-blog.csdnimg.cn/20200729164857454.png" alt></p><p>如上图所示的一个完整回路，Ia 表示正向的电源回路，Ib 表示方向的地回路。两个回路各自存在自感，而互相之间又存在互感。当回路上的电流发生变化时，在电感的周围就形成磁场，电流变化增大，电感增强，而互感是阻碍自感的变化的。</p><p><img src="https://img-blog.csdnimg.cn/20200729165601775.png" alt></p><p>如上图的公式，电流的变化必然造成电路上电压的变化，对于正向，造成的问题就是稳压器的输出与芯片的输入端电压不一致，V 就是电源路径上的噪声，造成电源轨道塌陷。而在返回的回路上（一般是地），因为存在一个 V 大小的电压，导致地平面发生变化，造成地弹噪声。</p><p><strong>可知：</strong> 由于<strong>电流变化引起</strong>的感应电动势的变化是产生电源噪声的原因，如何减弱这种影响，也就是有效的对系统的电源完整性进行控制。</p><p><strong>措施：</strong> </p><p>（1）尽量减小回路中电流的变化率，稳定负载的变化造成电流的瞬变，稳定电流的大小；</p><p>（2）减少电路走线、接线的电感，这就是走线尽可能短、宽的原因，减少电路本身的自感。</p><h3 id="4-3-电容（C）"><a href="#4-3-电容（C）" class="headerlink" title="4.3 电容（C）"></a>4.3 电容（C）</h3><p>去耦电容是目前电路中解决电源噪声的主要方式，此处也主要是对针对电容的去耦作用。</p><h4 id="4-1-1-电容的储能作用"><a href="#4-1-1-电容的储能作用" class="headerlink" title="4.1.1 电容的储能作用"></a>4.1.1 电容的储能作用</h4><p>如下图，上电过程中，电源对电容进行充电，一段时间之后电容就存储了一定的电荷量（相当于蓄水池）。如果负载的电流保持不变，即负载上的电压是稳定的，因此电容两端的电压也是恒定的且等于负载两端的电压，此时 Ic = 0，负载的电流由 Io 提供。</p><p><img src="https://img-blog.csdnimg.cn/20200729173234298.png" alt></p><p>如果负载电流突然发生变化，而晶体管的切换速度极快，稳压源的输出跟不上这种变化，Io 无法及时变化满足负载的变化，就会拉低供电的电压，这时，电容也感知到两端电压的变化，这样电容的变化对应着有电流的产生，Ic 不再为 0，就可以为负载提供一定大小的电流，计算公式如下图。这个过程中，电容分担了稳压源的一部分输出电流。</p><p><img src="https://img-blog.csdnimg.cn/20200729172707951.png" alt></p><h4 id="4-2-1-阻抗"><a href="#4-2-1-阻抗" class="headerlink" title="4.2.1 阻抗"></a>4.2.1 阻抗</h4><p>如下图，从右往左看，我们可以把电源和电容复合看做是一个整体的稳压源。</p><p><img src="https://img-blog.csdnimg.cn/20200729174139492.png" alt><br>我们要达到的目的是，AB 两点之间的负载电流发生变化，都要尽可能让 AB 两点的电压保持稳定。</p><p><img src="https://img-blog.csdnimg.cn/20200729174550665.png" alt></p><p>对于这个电源模型，我们等效为上述的公式，就可以清晰的知道 I 发生变化，而 V 几乎不变，这就要求阻抗 Z 足够小。电容的特性是：阻直流，通交流。从这个角度来看，耦合电容一定程度上降低了整个电源系统的阻抗。</p><p><strong>去耦的关键是做好电容种类和数量的搭配，并非一味的增加总容量。</strong></p><h4 id="4-3-3-简化模型"><a href="#4-3-3-简化模型" class="headerlink" title="4.3.3 简化模型"></a>4.3.3 简化模型</h4><p>实际的电路之中，电容不仅仅是电容，还有一些等效的参数，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200729175547564.png" alt></p><p>在不同的频段，电容表现出不同的特性。电容的容抗如下;</p><p><img src="https://img-blog.csdnimg.cn/20200729181245828.png" alt></p><p>fo 为电容的谐振频率，处在谐振点，电容呈现纯阻特性，小于谐振频率时，呈现容性，大于谐振频率，呈现感性。</p><p>然而去耦电容都有一定的工作频率，只有在谐振点的附近，电容才具有最佳的电容特性。</p><p>电容的阻抗特性如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200729182429105.png" alt></p><p>不同的电容有不同的谐振频率，如果工作的频率变化范围比较宽，一般采用大电容和小电容并联一起使用。电容越大，谐振点越低。</p><h4 id="4-3-4-品质因数（Q）"><a href="#4-3-4-品质因数（Q）" class="headerlink" title="4.3.4 品质因数（Q）"></a>4.3.4 品质因数（Q）</h4><p>RLC 的串联电路 Q 值定义为：电路串联谐振时，感抗/容抗与纯电阻的比重。Q 值描述的是电路的选频特性，计算公式如下：</p><p><img src="https://img-blog.csdnimg.cn/20200729194724239.png" alt></p><p>Q 值越大，电路的频率选择性越好，允许通过的电流频段越窄。但是在电源去耦的时候，负载芯片上有瞬态电流需求时，去耦电容要立刻给与补偿，如果 Q 值很大，可以流过电容的补偿电流就会变窄，影响电容人的去耦能力，一般用于电源去耦的时候，选择 Q 值较小的电容。一般在板级滤波的时候，会放置一些容量较大的钽电容或电解电容，这两类电容的额 Q 值较低，可以提供比较宽的有效去耦频率范围。</p><h4 id="4-3-5-电容并联"><a href="#4-3-5-电容并联" class="headerlink" title="4.3.5 电容并联"></a>4.3.5 电容并联</h4><p>（1）相同容值的 n 个电容并联合后，谐振频率不变，阻抗点的阻抗变为了原来的 1/n。</p><p><img src="https://img-blog.csdnimg.cn/20200729232558447.png" alt></p><p>（2）不同容值的电容并联，因为每个电容的谐振频率不一样，当工作频率处于两个谐振频率之间，一些电容表现为容性，一些电容表现为感性，就构成了一个 LC 并联的电路，LC 并联谐振的时候，在两个电容的自谐振频率点之间出现并联谐振峰，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200729234838801.png" alt></p><p>为了使整个 PDN 系统的阻抗小于目标阻抗，必须严格控制并联谐振峰的大小。</p><h4 id="4-3-6-去耦电容的配置方式"><a href="#4-3-6-去耦电容的配置方式" class="headerlink" title="4.3.6 去耦电容的配置方式"></a>4.3.6 去耦电容的配置方式</h4><p>（1）Big-V方法：通常的做法就是在芯片每个供电引脚的周围添加几个 0.1uF 的电容，另外再增加几个百微法级别的板级滤波电容。但由前文的介绍可知，同一类型的电容并联使阻抗降低，但跟大电容并联后依然容易形成并联谐振峰，很有可能在 LC 并联形成的并联谐振峰超过了系统的目标阻抗，这个是我们不希望看到的。</p><p><img src="https://img-blog.csdnimg.cn/2020073009083919.png" alt></p><p>（2）Multi-Pole：使用多种容值的电容并联起来，形成去耦网络。主要分为两种方式：在十倍程的范围内选择一种电容还是三种电容。</p><table><thead><tr><th align="center">十倍程一种电容</th><th align="center">十倍程三种电容</th></tr></thead><tbody><tr><td align="center">10uF - 1uF - 0.1uF</td><td align="center">10uF - 4.7uF - 2.2uF - 1uF - 0.47uF - 0.22uF - 0.1uF</td></tr></tbody></table><p>使用 Multi-Pole 方式有比较好的阻抗曲线平坦度，能够满足阻抗一直低于目标阻抗。</p><p>各种电容的作用范围如下：</p><p><img src="https://img-blog.csdnimg.cn/20200730095843240.png" alt></p><p>在 PDN 系统中，一般要选择等效串联电阻（ESR）和等效串联电感（ESL）比较低的电容来作为去耦电容。</p><h4 id="4-3-7-去耦电容的摆放位置"><a href="#4-3-7-去耦电容的摆放位置" class="headerlink" title="4.3.7 去耦电容的摆放位置"></a>4.3.7 去耦电容的摆放位置</h4><p>去耦电容的连接方式一段连接芯片的电源引脚，另一端连接地，针对芯片的复杂度和通信速率，分为引脚去耦和平面去耦两种方式。</p><p>电容的摆放根据容值的大小放置的位置也有区别，因为不同电容的去耦半径是不一样的，如果摆放的位置已经超出了电容的去耦范围，那么电容的去耦作用也就失效了，所以，<strong>根据去耦半径的范围，小电容应该距离芯片的供电引脚近一些，而大电容相对远一些</strong>。</p><p>，<img src="https://img-blog.csdnimg.cn/20200730092405634.png" alt></p><p>去耦电容的安装核心是减小安装电感。对于在电路板上的连接和过孔的方式是有一定的要求的。原则是：<strong>电容引线尽可能的短，电容单独打孔，引线尽可能和焊盘的宽度一致，电源和地之间的回路尽可能小</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200730093204971.png" alt></p><p>上图的（2），（3）是推荐的使用方式，（1）引线又细又长，无疑增加了引线的电感，这与去耦的初衷是相违背的，应该杜绝，（4）是的摆放位置最好，但是占用 PCB 的面积。</p><h4 id="4-3-8-目标阻抗设计"><a href="#4-3-8-目标阻抗设计" class="headerlink" title="4.3.8 目标阻抗设计"></a>4.3.8 目标阻抗设计</h4><p>目标阻抗法是目前最具有可操作性的 PDN 系统的去耦方式，核心思想是：利用电流的变化量、阻抗、电压变化量之间的线性约束关系。</p><p>PDN 系统的等效模型：</p><p><img src="https://img-blog.csdnimg.cn/20200730094525603.png" alt></p><p>约束关系： ∆V=  (Z * ∆I)，根据稳压芯片的输出，∆V 我们是可以计算的，只要能够确定负载芯片的最大瞬态电流变化量，那么阻抗 Z 的大小也就对应可以控制，这个最大阻抗就是 PDN 系统的设计目标，系统的阻抗要在工作的频段内低于目标阻抗。目标阻抗的计算方式如下：</p><p><img src="https://img-blog.csdnimg.cn/20200730095121643.png" alt></p><p><strong>参数介绍：</strong> </p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">Ztarget</td><td align="center">目标阻抗</td></tr><tr><td align="center">Vcc</td><td align="center">芯片的供电，比如常见的：5V/3.3V/1.8V等</td></tr><tr><td align="center">Ripple</td><td align="center">允许的电压波动，比如±5%，±3 等</td></tr><tr><td align="center">∆Imax</td><td align="center">负载芯片的最大瞬态电流</td></tr></tbody></table><p>为了保证信号的完整性，电源分配系统的阻抗必须低于目标阻抗。</p><hr><h2 id="5-总结一下"><a href="#5-总结一下" class="headerlink" title="5. 总结一下"></a>5. 总结一下</h2><p>本文主要是个人在学习电源完整性过程中的一些笔记总结，用于经常复习，参考的连接在文末已给出，感谢他们。本人能力有限，表述记录的过程中难免有疏漏，欢迎大家积极交流讨论。</p><p>解决直流压降的核心是：尽可能增大供电电路上的过流面积，采取的措施有加宽电源层，地平面的宽度，我们可以见到一般高速复杂的 PCB 都需要提供单独的电源层和地层；另外就是减少电源的回路面积，缩短电源到芯片的距离，增加铜箔厚度等措施。</p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><h2 id="6-参考："><a href="#6-参考：" class="headerlink" title="6. 参考："></a>6. 参考：</h2><ol><li><a href="http://murata.eetrend.com/article/2018-11/1002201.html" target="_blank" rel="noopener">PCB设计中要考虑电源信号的完整性</a></li><li><a href="https://resources.altium.com/cn/p/pdn-impedance-analysis-and-modeling-from-schematic-to-layout" target="_blank" rel="noopener">电源完整性| PCB设计资源</a></li><li>[书籍——于博士信号完整性]</li><li><a href="https://www.cnblogs.com/shenhaocn/p/6059516.html" target="_blank" rel="noopener">电源分配系统及电源完整性</a></li><li><a href="http://www.edatop.com/ee/197159.html" target="_blank" rel="noopener">电源分配系统设计方法与技术分析</a></li><li><a href="https://resources.altium.com/cn/p/pdn-impedance-analysis-and-modeling-from-schematic-to-layout" target="_blank" rel="noopener">PDN阻抗分析和建模：从原理图到PCB布局</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hardware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电源完整性(PI) </tag>
            
            <tag> 信号完整性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Allegro专题【5】——Orcad to PCB Editor</title>
      <link href="/2020/06/27/allegro-zhuan-ti-5-orcad-to-pcb-editor/"/>
      <url>/2020/06/27/allegro-zhuan-ti-5-orcad-to-pcb-editor/</url>
      
        <content type="html"><![CDATA[<hr><p>前面已经基本完成了原理图库和器件封装库的制作，接下来，正式开始到原理图和 PCB 的设计。这里是以 STM32 的开发板为例。</p><hr><h2 id="1-Orcad"><a href="#1-Orcad" class="headerlink" title="1. Orcad"></a>1. Orcad</h2><p>只要准备好了元器件的原理图库，剩下的就是按照电气特性完成连接。</p><p><img src="https://img-blog.csdnimg.cn/20200627152605381.png" alt></p><h3 id="1-1-DRC-检查"><a href="#1-1-DRC-检查" class="headerlink" title="1.1  DRC 检查"></a>1.1  DRC 检查</h3><p>做完原理图，我们需要进行 DRC 检查，就电气特性、物理特性等进行检查，这不是必要的。</p><p><img src="https://img-blog.csdnimg.cn/20200627152929459.PNG" alt></p><h3 id="1-2-封装设置"><a href="#1-2-封装设置" class="headerlink" title="1.2 封装设置"></a>1.2 封装设置</h3><p>关键的一个步骤是对器件的封装进行设置。如下图，我们选择原理图工程，右键 –&gt; 编辑对象属性找到 PCB Footprint 栏目对应修改器件的封装。</p><p><img src="https://img-blog.csdnimg.cn/20200627153207852.PNG" alt></p><h3 id="1-3-BOM-导出"><a href="#1-3-BOM-导出" class="headerlink" title="1.3 BOM 导出"></a>1.3 BOM 导出</h3><p>BOM 的导出，同样选择原理图工程文件，然后在 Tools 菜单下，执行 BOM 导出。<br><img src="https://img-blog.csdnimg.cn/20200627153815991.PNG" alt></p><h3 id="1-4-网表导出"><a href="#1-4-网表导出" class="headerlink" title="1.4 网表导出"></a>1.4 网表导出</h3><p>网表导出，这一点不同于 Altium Designer ，原理图可以直接就导入到 PCB 编辑。Orcad 需要先导出网表文件，然后在使用 PCB Editor 导入网表（网表分为第一方网表和第三方网表，注意两者导出、导入时设置是不一样的）。我们同样在 Tools 菜单下，执行网表的导出操作。</p><p><img src="https://img-blog.csdnimg.cn/20200627154247682.PNG" alt></p><p>第一方网表的导出设置如下：</p><p><img src="https://img-blog.csdnimg.cn/2020062715441589.png" alt></p><p>第三方网表的导出设置如下（这里也是导入 allegro ，导入如 AD 、 PADS 等平台选择不同的连接库）</p><p><img src="https://img-blog.csdnimg.cn/20200627155140675.png" alt></p><hr><h2 id="2-Allegro"><a href="#2-Allegro" class="headerlink" title="2. Allegro"></a>2. Allegro</h2><h3 id="2-1-板框绘制"><a href="#2-1-板框绘制" class="headerlink" title="2.1 板框绘制"></a>2.1 板框绘制</h3><p>（1）板框层的绘制，选择 Outline 层进行设置（类似于 AD 的 KEEP-OUT 层）</p><p><img src="https://img-blog.csdnimg.cn/20200627155908269.png" alt></p><h3 id="2-2-DXF-板框导入"><a href="#2-2-DXF-板框导入" class="headerlink" title="2.2 DXF 板框导入"></a>2.2 DXF 板框导入</h3><p>板框通过 CAD 的 DXF 文件的导入</p><p><img src="https://img-blog.csdnimg.cn/20200627160052155.PNG" alt></p><p>参数设置：</p><p><img src="https://img-blog.csdnimg.cn/20200627160555966.png" alt></p><p>映射层到 Allegro：</p><p><img src="https://img-blog.csdnimg.cn/20200627160756151.png" alt></p><p>导入之后使用 Edit —&gt; Change 命令修改到 Outline 层：</p><p><img src="https://img-blog.csdnimg.cn/20200627161158360.png" alt></p><p>导入板框之后，我们可以按照需求，依次设置器件放置区域和布线区域。</p><p>不同层（顶视图、底视图）可通过板框的定位孔，通过坐标的方式进行合并。</p><h3 id="2-3-导入网表"><a href="#2-3-导入网表" class="headerlink" title="2.3 导入网表"></a>2.3 导入网表</h3><p><img src="https://img-blog.csdnimg.cn/20200627161444124.PNG" alt></p><p>导入第一方网表：</p><p><img src="https://img-blog.csdnimg.cn/20200627161601184.png" alt></p><p>导入之后，allegro 会生成导入的报告，如果没有 error ，则表示导入成功。如下图，通过查看 Status ，可知第一方网表已经成功导入了。</p><p><img src="https://img-blog.csdnimg.cn/20200627161857763.PNG" alt></p><h3 id="2-4-放置器件"><a href="#2-4-放置器件" class="headerlink" title="2.4 放置器件"></a>2.4 放置器件</h3><p>分为手动放置，自动放置，Room 区域放置等。</p><p><img src="https://img-blog.csdnimg.cn/20200627162247426.PNG" alt></p><p>这里选择快速放置，我们可以看到器件已经成功导入到 PCB 之中了。</p><p><img src="https://img-blog.csdnimg.cn/20200627162504949.png" alt></p><h3 id="2-5-飞线设置"><a href="#2-5-飞线设置" class="headerlink" title="2.5 飞线设置"></a>2.5 飞线设置</h3><p>隐藏和显示飞线：</p><p><img src="https://img-blog.csdnimg.cn/20200627162806114.png" alt></p><p>显示同一网络（Part 等）飞线设置，选择对应属性，就可以显示出对应属性的飞线。</p><p><img src="https://img-blog.csdnimg.cn/20200627162927673.PNG" alt></p><h3 id="2-6-交互式布局"><a href="#2-6-交互式布局" class="headerlink" title="2.6 交互式布局"></a>2.6 交互式布局</h3><p>通过交互式布局，是我们高效的完成元器件在 PCB 上布局的关键步骤。操作如下：</p><p>（1）在 PCB Editor 中选择 Move 命令；</p><p>（2）回到 Orcad 选择要分离模块电路；</p><p>（3）PCB Editor ，我们发现原理图中选中的器件已经被选择了，然后鼠标拖动，即可分离出模块电路，如下图;</p><p><img src="https://img-blog.csdnimg.cn/20200627163835476.png" alt></p><p>补充：对于多张原理图设计，也可以在原理图中每张图纸设置一个 room 编号，这样在 PCB 中放置的时候，首先绘制出 room 区域，导入的时候，就可以把器件放置到对应的 room 框中。</p><h3 id="2-7-器件与板框之间的定位"><a href="#2-7-器件与板框之间的定位" class="headerlink" title="2.7 器件与板框之间的定位"></a>2.7 器件与板框之间的定位</h3><p>我们先选择器件对应的引脚或者定位孔，然后确定板框定位孔的坐标，使用 Move 操作通过坐标放到对应的位置，选择的对象为 Pins 。</p><p><img src="https://img-blog.csdnimg.cn/20200627170611616.png" alt></p><hr><p>至此，我们就基本完成了 Orcad 到 allegro的操作。</p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hardware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
            <tag> Allegro </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB总线专题（五）——Mass storage 设备相关知识</title>
      <link href="/2020/02/18/usb-zong-xian-zhuan-ti-wu-mass-storage-she-bei-xiang-guan-zhi-shi/"/>
      <url>/2020/02/18/usb-zong-xian-zhuan-ti-wu-mass-storage-she-bei-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-SCSI-协议定义"><a href="#1-SCSI-协议定义" class="headerlink" title="1. SCSI 协议定义"></a>1. SCSI 协议定义</h2><p>小型计算机系统接口（SCSI，Small Computer System Interface）：是一种用于计算机及其周边设备之间（硬盘、软驱、光驱、打印机、扫描仪等）系统级接口的独立处理器标准。SCSI 标准定义命令、通信协议以及实体的电气特性（换成 OSI 的说法，就是占据物理层、链接层、套接层、应用层），最大部分的应用是在存储设备上（例如硬盘、磁带机），除外，SCSI 可以连接的设备包括有扫描仪、光学设备（像 CD、DVD）、打印机等等，SCSI 命令中有条列出支持的设备 SCSI 周边设备。理论上，SCSI 不可能连接所有的设备，所以有 “1Fh - unknown or no device type” 这个参数存在。</p><p>SCSI 协议的主要功能是在主机和存储设备之间传送命令、状态和块数据。</p><h2 id="2-SCSI-协议特点"><a href="#2-SCSI-协议特点" class="headerlink" title="2. SCSI 协议特点"></a>2. SCSI 协议特点</h2><p>（1）SCSI 可以划分为 SCSI-1、SCSI-2、SCSI-3，最新的为 SCSI-3，也是目前应用最广泛的 SCSI 版本。</p><h2 id="3-SCSI-协议"><a href="#3-SCSI-协议" class="headerlink" title="3. SCSI 协议"></a>3. SCSI 协议</h2><p>Scsi 协议是U盘，读卡器这些大容量存储所使用的协议，整个协议是工作在<strong>批量传输</strong>，分为输入跟输出两个方向。到两个概念：CBW；CSW。当这些大批量设备传输完成了后，主机会识别到你当前的设备是大容量设备，根据 SCSI 的协议来发送 CBW 包下来，CBW 包可理解为主机的一个命令包，我们要去解释这个命令包去进行相应的处理，当数据处理完后，就要回复 CSW 包，这相当于 SCSI 协议的一个应答包，是对刚才 CBW 包的处理情况的一个回应。</p><p><img src="https://img-blog.csdnimg.cn/20200213161052927.png" alt></p><p>设备插入到 USB 后，USB 即对设备进行搜索，并要求设备提供相应的描述符。在USB Host 得到描述符后，即完成设备的配置，识别出为 Bulk－Only 的 Mass Storage 设备，然后即进入Bulk－Only 传输方式。</p><p>在此方式下，USB 与设备间的所有数据均通过 Bulk－In 和 Bulk－Out 来进行传输，不再通过控制端点传输任何数据。 在这种传输方式下，有三种类型的数据在USB 和设备之间传送，CBW、CSW 和普通数据。CBW（Command Block Wrapper，即命令块包）是从USB Host 发送到设备的命令，命令格式遵从接口中的 bInterfaceSubClass 所指定的命令块，这里为 SCSI 传输命令集。USB 设备需要将 SCSI 命令从 CBW 中提取出来，执行相应的命令，完成以后，向 Host 发出反映当前命令执行状态的 CSW（Command Status Wrapper），Host 根据 CSW 来决定是否继续发 送下一个CBW 或是数据。</p><p> Host 端发送的数据必须符合 CBW 格式（31byte，小端模式），而 Mass Storage 设备的应答，其格式必须符合 CSW 格式（13byte，小端模式）。中间过程传输的数据，根据不同的命令，格式也有不同地要求。</p><h3 id="3-1-CBW-包结构及解释："><a href="#3-1-CBW-包结构及解释：" class="headerlink" title="3.1 CBW 包结构及解释："></a>3.1 CBW 包结构及解释：</h3><p><img src="https://img-blog.csdnimg.cn/20200212161612361.png" alt></p><table><thead><tr><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">dCBWSignature</td><td align="center">CBW 数据包标识，为常数 0x43425355（小端）</td></tr><tr><td align="center">dCBWTag</td><td align="center">主机发送的一个命令块标志，设备应该回复一个包含同样信息的  dCSWTag 来相应 CBW</td></tr><tr><td align="center">dCBWDataTransferLength</td><td align="center">在执行本条命令的时候，主机期待通过 Bulk 端点传输的数据长度，如果此值为 0，表示主机和设备之间没有数据传输，设备应该应该忽略 bmCBWFlags 的值</td></tr><tr><td align="center">bmCBWFlags</td><td align="center">如果 dCBWDataTransferLength = 0，此值忽略，否则表示如下：Bit7：0 — Data out （主机——&gt;设备）；1— Data in（设备——&gt;主机）；Bit6：不使用，主机应该将其设置为 0；Bit 5…0：保留，主机应该将其设置为0</td></tr><tr><td align="center">bCBWLUN</td><td align="center">表示设备正在发送的逻辑单元，对于支持多个逻辑单元的设备，主机应根据对应的地址设置数值，否则，主机应该将数值设置为 0</td></tr><tr><td align="center">bCBWCBLength</td><td align="center">CBW 命令块数据中的有效字节，合法的数值为 1~16，其他值被保留</td></tr><tr><td align="center">CBWCB</td><td align="center">设备执行的命令块，符合bInterfaceSubClass.中定义的命令规范，此处是SCSI指令集</td></tr></tbody></table><p>结构体定义：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _CBW<span class="token punctuation">{</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCBWSignature<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// dwCBWSignature: the constant 0x55 0x53 0x42 0x43(LSB)</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCBWtag<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// dwCBWtag:</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCBWXferLength<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dwCBWXferLength:number of bytes to transfer</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bCBWFlags<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// bmCBWFlags:</span>                                    <span class="token comment" spellcheck="true">//   Bit 7: direction - the device shall ignore this bit if the</span>                                    <span class="token comment" spellcheck="true">//   dCBWDataTransferLength field is zero, otherwise:</span>                                    <span class="token comment" spellcheck="true">//   0 = Data-Out from host to the device,</span>                                    <span class="token comment" spellcheck="true">//   1 = Data-In from the device to the host.</span>                                    <span class="token comment" spellcheck="true">//   Bit 6: obsolete. The host shall set this bit to zero.</span>                                    <span class="token comment" spellcheck="true">//   Bits 5..0: reserved - the host shall set these bits to zero.</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bCBWlun<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// bmCBWlun:</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bCBWCBLength<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// bCBWLength: 0x01..0x10</span>  CDB cdb<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// CBWCB: the command descriptor block</span><span class="token punctuation">}</span> CBW<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-CSW-包结构及解释："><a href="#3-2-CSW-包结构及解释：" class="headerlink" title="3.2 CSW 包结构及解释："></a>3.2 CSW 包结构及解释：</h3><p><img src="https://img-blog.csdnimg.cn/20200212171914212.png" alt></p><table><thead><tr><th align="center">名称</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">dCSWSignature</td><td align="center">CSW 命令块标识，值为 0x53425355（小端）</td></tr><tr><td align="center">dCSWTag</td><td align="center">值为收到的 dCBWTag ，同样返回给 主机</td></tr><tr><td align="center">dCSWDataResidue</td><td align="center">仍需要传送的数据，等于 dCBWDataTransferLength－本次已经传送的数据</td></tr><tr><td align="center">bCSWStatus</td><td align="center">指示命名是否成功传输（00H—成功；01H—失败；02H—传输过程错误；03~FFH：保留）</td></tr></tbody></table><p>结构体定义：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _CSW<span class="token punctuation">{</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCSWSignature<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// dwCSWSignature: the constant 0x53 0x42 0x53 0x55</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCSWtag<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// dwCSWtag:</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dwCSWResidue<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// dwCBWXferLength:  number of bytes not transferred</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bCSWStatus<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// bCSWStatus:</span>                                   <span class="token comment" spellcheck="true">//  00h command Passed ("good status")</span>                                   <span class="token comment" spellcheck="true">//  01h command failed</span>                                   <span class="token comment" spellcheck="true">//  02h phase error</span>                                   <span class="token comment" spellcheck="true">//  03h to FFh reserved</span><span class="token punctuation">}</span>CSW<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-SCSI命令集——Mass-Storage-设备"><a href="#3-3-SCSI命令集——Mass-Storage-设备" class="headerlink" title="3.3 SCSI命令集——Mass Storage 设备"></a>3.3 SCSI命令集——Mass Storage 设备</h3><table><thead><tr><th align="center">指令</th><th align="center">标识</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">Test Unit Ready</td><td align="center">查询设备是否ready</td></tr><tr><td align="center">0x03</td><td align="center">Request Sense</td><td align="center">主机请求设备返回执行结果，及获取状态信息</td></tr><tr><td align="center">0x04</td><td align="center">Format Unit</td><td align="center">格式化存储设备</td></tr><tr><td align="center">0x12</td><td align="center">Inquiry</td><td align="center">获取设备信息</td></tr><tr><td align="center">0x1A</td><td align="center">Mode Sense(6)</td><td align="center">向 host 传输参数</td></tr><tr><td align="center">0x5A</td><td align="center">Mode Sense(10)</td><td align="center">向 host 传输参数</td></tr><tr><td align="center">0x25</td><td align="center">Read Capacity(10)</td><td align="center">读取设备容量</td></tr><tr><td align="center">0x28</td><td align="center">Read(10)</td><td align="center">Host 从设备读取数据</td></tr><tr><td align="center">0x2A</td><td align="center">Write(10)</td><td align="center">Host 写数据到存储设备</td></tr><tr><td align="center">0x23</td><td align="center">Read Format Capacity</td><td align="center">查询当前容量及可用空间</td></tr><tr><td align="center">0x15</td><td align="center">Mode Select(6)</td><td align="center">允许 Host 对外部设备设置参数</td></tr><tr><td align="center">0x55</td><td align="center">Mode Select(10)</td><td align="center">允许 Host 对外部设备设置参数</td></tr><tr><td align="center">0x1E</td><td align="center">Prevent/Allow Medium Removal</td><td align="center">禁止/允许存储介质移动</td></tr><tr><td align="center">0x1B</td><td align="center">Start/Stop Uint</td><td align="center">加载/卸载可移动设备</td></tr><tr><td align="center">0x2B</td><td align="center">Seek(10)</td><td align="center">为设备分配地址</td></tr><tr><td align="center">0xA0</td><td align="center">Report LUNs</td><td align="center">索取设备的 LUN 数和 LUN 清单</td></tr><tr><td align="center">0x2F</td><td align="center">Verify</td><td align="center">在存储中验证数据</td></tr></tbody></table><p><strong>命令举例：</strong></p><p>READ(10) ：0x28</p><p><img src="https://img-blog.csdnimg.cn/20200218102809790.png" alt></p><h3 id="3-4-SCSI-指令流程"><a href="#3-4-SCSI-指令流程" class="headerlink" title="3.4 SCSI 指令流程"></a>3.4 SCSI 指令流程</h3><p>USB MSC设备中的固件（firmware）或者硬件（hardware），必须要实现下面这些功能：</p><p>（1）检测和响应通用的 USB Request 和 USB 总线上的事件；</p><p>（2）检测和响应来自 USB 设备的关于信息或者动作的 USB Mass Storage Request；</p><p>（3）检测和响应，从 USB Transfer 中获得的 SCSI Command。这些业界标准的命令，是用来获得状态信息，控制设备操作，向存储介质块中读取（read block）和写入（write block）数据的。</p><p><strong>指令收发简述：</strong></p><p>a. 主机首先发出 Inquiry 命令，设备响应了 Inquiry 之后就可以看到盘符；</p><p>b. Inquiry 之后会发出 ReadFormatCapacity 命令，这个命令在 SCSI 规范中是“厂家自定义命令”,可参考 UFI 命令集文档（实际上，U 盘所使用的所有 SCSI 命令集都可以参考 UFI 文档，它比 SCSI 标准文档更简洁明了）。注意：这个命令在BusHound 里是没有描述的，必须在 “Device” 选项页里勾选上这个 U 盘所对应的USB Mass Storage Device 这个节点，才能看到这个命令的数据流；</p><p>c. ReadFormatCapacity 之后会发出 ReadCapacity 命令，ReadCapacity 完成后就会发送 Read(10) 读取U盘的第一个扇区；</p><p>d. U盘读数据（读扇区）时会发送 Read(10);</p><p>e.  U 盘写数据时（写扇区）会发送 Write(10);</p><p>f. Test Unit Ready 会在无其他数据传输时会定时发送，如果设备没有回应成功的 CSW 给主机，则主机认为设备已不存在。此时如果再双击磁盘图标，Windows 会提示“请插入磁盘”;</p><p>g. Verify 在写数据时有用，表示核实数据，一般直接返回成功的 CSW 就可以了。一般来说，数据校验的工作在接收和向介质写数据时就已经顺带做了，如果发现错误，则直接告诉主机那次的数据传输有误，不会等到主机 Verify 时;</p><p>h. RequestSense：如果 CSW 指示此次传输不成功，那么主机会发出此请求;</p><p>i. StartStop 暂时未发现大用处，一般直接返回成功的CSW；</p><p>j. MediumRemoval 在 U 盘被 Eject 的时候有用，处理不正确会 Windows 会弹出错误信息；</p><p>k. ModeSense6/ModeSense10 这两个命令可以不支持（不支持不代表不反应，任何一个命令你都要做出反应，对于不支持的命令，可以通过 STALL 握手来向主机表明），暂时也未遇到过什么异常情况，而且我查看过一些 U 盘，有相当一部分就是随便回了几个数据给主机。这两个命令只会在 U 盘插入后发送一次，此后不再发送。</p><h3 id="3-5-数据交换流程"><a href="#3-5-数据交换流程" class="headerlink" title="3.5 数据交换流程"></a>3.5 数据交换流程</h3><p>通过 bulk 端点进行的数据传输，都遵循这样一个过程，即三个阶段：</p><p><strong>CBW-&gt;DATA-&gt;CSW</strong></p><p>CBW 是一个数据块，携带主机发给设备的 SCSI 命令。接收了 CBW 后，设备就可以从中知道在接下来的 DATA 阶段中该干什么。DATA阶段（无数据需要传输；<br>IN 传输（设备到主机）或 OUT 传输（主机到设备））。</p><h2 id="4-数据实例分析"><a href="#4-数据实例分析" class="headerlink" title="4. 数据实例分析"></a>4. 数据实例分析</h2><p>下图是通过 bus hound 抓取 U 盘插入的数据，可以看到 SCSI 命令及 CBW 、CSW 的指令包交互过程：</p><p><img src="https://img-blog.csdnimg.cn/20200217175937641.png" alt></p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">小型计算机系统接口</a></p></li><li><p><a href="https://www.crifan.com/files/doc/docbook/usb_disk_driver/release/htmls/ch02_msc_basic.html" target="_blank" rel="noopener">第 2 章 USB Mass Storage大容量存储的基本知识</a></p></li><li><p><a href="https://www.wikiwand.com/zh-cn/%E5%B0%8F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">小型计算机系统接口</a></p></li><li><p><a href="https://blog.csdn.net/witxjp/article/details/8266605" target="_blank" rel="noopener">SCSI指令格式详解</a></p></li><li><p><a href="https://blog.csdn.net/hamin123/article/details/42499825" target="_blank" rel="noopener">USB与SCSI</a></p></li><li><p><a href="https://www.cnblogs.com/shangdawei/archive/2013/06/13/3133526.html" target="_blank" rel="noopener">USB Mass Storage大容量存储的基本知识</a></p></li><li><p><a href="http://www.52rd.com/Blog/Detail_RD.Blog_whisperer_26805.html" target="_blank" rel="noopener">嵌入式系统USB CDROM虚拟光驱驱动程序开发</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> USB 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> USB </tag>
            
            <tag> Mass Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil使用总结（一）——拷贝调试中内存数据到文本文件</title>
      <link href="/2020/01/14/keil-shi-yong-zong-jie-yi-kao-bei-diao-shi-zhong-nei-cun-shu-ju-dao-wen-ben-wen-jian/"/>
      <url>/2020/01/14/keil-shi-yong-zong-jie-yi-kao-bei-diao-shi-zhong-nei-cun-shu-ju-dao-wen-ben-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>我们在调试过程中，不免需要查看从一些设备（比如：传感器，采集器等设备）读取的数据，在使用 Keil 调试的时候，就可以从 Memory 窗口将数据保存到计算机本地，对应进行分析。</p><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-打开-Command-窗口"><a href="#2-1-打开-Command-窗口" class="headerlink" title="2.1 打开 Command  窗口"></a>2.1 打开 Command  窗口</h3><p>在调试状态下，如下图所示，打开 Command Window 项目栏：</p><p><img src="https://img-blog.csdnimg.cn/20200114193412724.png" alt></p><h3 id="2-2-打开-Memory-窗口"><a href="#2-2-打开-Memory-窗口" class="headerlink" title="2.2 打开 Memory  窗口"></a>2.2 打开 Memory  窗口</h3><p>打开 Memory Window 项目栏，输入将要查看的变量地址，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200114193537576.png" alt></p><p>此处仅作为举例，有效数据为红框部分。</p><h3 id="2-3-保存数据"><a href="#2-3-保存数据" class="headerlink" title="2.3 保存数据"></a>2.3 保存数据</h3><p>如下图所示，在 Command Window 输入：SAVE E:\Debug\DATA.txt 0x20004A18,0x20004A3A。</p><p><img src="https://img-blog.csdnimg.cn/20200114193736736.png" alt><br>回车确认，及可在对应的目录下找到保存的数据文件.</p><p><img src="https://img-blog.csdnimg.cn/20200114194753575.png" alt></p><p>命令字段介绍：</p><table><thead><tr><th align="center">标识</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">SAVE</td><td align="center">操作命令</td></tr><tr><td align="center">E:\Debug</td><td align="center">保存的路径</td></tr><tr><td align="center">DATA.txt</td><td align="center">保存的文件名</td></tr><tr><td align="center">0x20004A18,0x20004A3A</td><td align="center">数据所在的地址范围</td></tr></tbody></table><h3 id="2-4-数据格式"><a href="#2-4-数据格式" class="headerlink" title="2.4 数据格式"></a>2.4 数据格式</h3><p>打开保存的数据，如下图所示，红框为提取的数据。</p><p><img src="https://img-blog.csdnimg.cn/20200114194858444.png" alt></p><p>数据格式为 hex 格式，需要掐头去尾，才能得到最终的数据，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200114195021841.png" alt></p><p>如上，就完成一次数据的复制保存。</p><p>关于 hex 文件与 bin 文件的区别，请参考<a href="https://blog.csdn.net/wwt18811707971/article/details/83758560" target="_blank" rel="noopener">STM32学习笔记一一HEX文件和BIN文件格式</a>此文，此处不再赘述。</p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Keil </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB总线专题（四）——枚举过程</title>
      <link href="/2019/09/11/usb-zong-xian-zhuan-ti-san-miao-shu-fu/"/>
      <url>/2019/09/11/usb-zong-xian-zhuan-ti-san-miao-shu-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>USB 描述符信息存储在 USB 设备中，在枚举过程中，USB 主机会向 USB 设备发送 GetDescriptor 请求，USB 设备在收到这个请求之后，会将 USB 描述符信息返回给 USB 主机，USB 主机分析返回来的数据，判断出该设备是哪一种 USB 设备，建立相应的数据链接通道。</p><p>USB 设备使用描述符报告其属性。描述符是具有定义格式的数据结构，每个描述符都以字节宽度字段开头，该字段包含描述符中的总字节数，后跟一个标识描述符类型的字节宽度字段。在 USB 设备枚举过程中，主机端的协义软件需要解析从 USB 设备读取的所有描述符信息。在 USB 主向设备发送读取描述符的请求后，USB 设备将所有的描述符以连续的数据流方式传输给 USB 主机。主机从第一个读到的字符开始，根据双方规定好的数据格式，顺序地解析读到的数据流。</p><p>每个 USB 设备公开的设备描述符，指示设备的类信息、 供应商和产品标识符，以及多个配置。 每个配置还公开其配置描述符，该值指示大量接口和功耗特征。 每个接口公开其包含类和数量的终结点信息的替代设置的每个接口描述符。 每个接口中的每个终结点公开终结点，描述符可指明终结点类型和最大数据包大小。</p><p>描述符类型：</p><p><img src="https://img-blog.csdnimg.cn/20190829102956752.png" alt></p><p>标准的 USB 设备有 5 种 USB 描述符：设备描述符（Device Descriptor)、配置描述符（Configuration Descriptor）、接口描述符（Interface Descriptor）、端点描述符（Endpoint Descriptor）和字符串描述符（String Descriptor）。描述符具有类似的格式，它们的第一个字段都是 bLength，第二个字段都是 bDescriptorType。七种描述符在使用时以 bDescriptorType 字段来区分。一设备至少要包含设备描述符、配置描述符和接口描述符，如果USB 设备没有端点描述符，则它仅仅用默认管道与主机进行数据传输。</p><p>每个 USB 设备只有一个设备描述符，而一个设备中可包含一个或多个配置描述符，即 USB 设备可以有多种配置。设备的每一个配置中又可以包含一个或多个接口描述符，即 USB 设备可以支持多种功能（接口），接口的特性通过描述符提供。</p><p><img src="https://img-blog.csdnimg.cn/20190829112936510.png" alt></p><p>在 USB 主机访问 USB 设备的描述符时，USB 设备依照设备描述符、配置描述符、接口描述符、端点描述符、字符串描述符顺序将所有描述符传给主机。一设备至少要包含设备描述符、配置描述符和接口描述符，如果 USB 设备没有端点描述符，则它仅仅用默认管道与主机进行数据传输。</p><h2 id="2-设备描述符"><a href="#2-设备描述符" class="headerlink" title="2. 设备描述符"></a>2. 设备描述符</h2><p>设备描述符描述的是设备的整体信息，与设备本身一一对应，包括对设备及在设备配置中起全程作用的信息，包括制造商标识号 ID、产品序列号、所属设备类号、默认端点的最大包长度和配置描述符的个数等。一个设备只能有一个设备描述符。在主机对 USB 设备枚举的过程中，首先要做的就是获取设备描述符，以对设备有一个整体的了解。</p><p>设备描述符由14个字段组成，总长度18字节：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _USB_DEVICE_DESCRIPTOR_<span class="token punctuation">{</span>    BYTE        bLength<span class="token punctuation">,</span>    BYTE        bDescriptorType<span class="token punctuation">,</span>    WORD        bcdUSB<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//2字节</span>    BYTE        bDeviceClass<span class="token punctuation">,</span>    BTYE        bDeviceSubClass<span class="token punctuation">,</span>    BYTE        bDeviceProtol<span class="token punctuation">,</span>    BYTE        bMaxPacketSize0<span class="token punctuation">,</span>    WORD        idVenderI<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//2字节</span>    WORD        idProduct<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//2字节</span>    WORD        bcdDevice<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//2字节</span>    BYTE        iManufacturer<span class="token punctuation">,</span>    BYTE        iProduct<span class="token punctuation">,</span>    BYTE        iSerialNumber<span class="token punctuation">,</span>    BYTE        iNumConfiguations<span class="token punctuation">}</span>USB_DEVICE_DESCRIPTOR<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* b  一个字节，=8bits； w  两个字节，=16bits； bm  按位寻址； bcd 用BCD码表示； i   索引值 id  标识码*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释：</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">描述符大小，固定为 0x12</td></tr><tr><td align="center">bDescriptorType</td><td align="center">设备描述符类型，固定为 0x01</td></tr><tr><td align="center">bcdUSB</td><td align="center">USB 规范发布号，表示了本设备能适用于那种协议，如 2.0=0200，1.1=0110 等</td></tr><tr><td align="center">bDeviceClass</td><td align="center">该设备所属的标准设备类，USB 协议中对常见的设备进行了分类。该字段值为 0x01～0xFE 时，表示是 USB 协议中已定义的设备类，常用的 HID 设备类编号为 0x03</td></tr><tr><td align="center">bDeviceSubClass</td><td align="center">子类型代码（由USB分配），如果 bDeviceClass 值是 0，一定要设置为 0．其它情况就跟据 USB-IF 组织定义的编码</td></tr><tr><td align="center">bDeviceProtocol</td><td align="center">协议代码（由USB分配），如果使用 USB-IF 组织定义的协议，就需要设置这里的值，否则直接设置为 0。如果厂商自己定义的可以设置为 FFH</td></tr><tr><td align="center">bMaxPacketSize0</td><td align="center">端点 ０ 最大分组大小（只有 8,16,32,64 有效）,对于低速 USB 设备，bMaxPacketSize0 为8；对于全速 USB 设备，bMaxPacketSize0 为 8、16、32、64；对于高速 USB 设备，bMaxPacketSize0 为 64。</td></tr><tr><td align="center">idVendor</td><td align="center">用于表示 USB 设备供应商的 ID。USB 组织中规定每种产品都必须包含一个供应商 ID,这样可以使主机加载合适的驱动程序。</td></tr><tr><td align="center">idProduct</td><td align="center">用于表示 USB 产品的 ID，由设备供应商提供。idProduct 用于表示特定的 USB 设备，在 USB 设备上电的时候可以帮助 USB 主机选择合适的驱动程序。</td></tr><tr><td align="center">bcdDevice</td><td align="center">用于表示 USB 设备的版本号，它以 BCD 码的形式表示。一般来说 bcdDevcie 由设备供应商指定，在 USB 设备上电的时候可以帮助 USB 主机选择合适的驱动程序。</td></tr><tr><td align="center">iManufacturer</td><td align="center">厂商描述符字符串索引．索引到对应的字符串描述符． 为 ０ 则表示没有</td></tr><tr><td align="center">iProduct</td><td align="center">产品描述符字符串索引</td></tr><tr><td align="center">iSerialNumber</td><td align="center">用于表示设备序列号字符串描述符的索引值，如果没有，可以置为 0</td></tr><tr><td align="center">bNumConfigurations</td><td align="center">用于表示该 USB 设备所支持的配置数。</td></tr></tbody></table><p>一个 USB CCID 设备的描述符为：与上表中的字段是一一对应的。</p><p><img src="https://img-blog.csdnimg.cn/20190829151855357.png" alt></p><h2 id="3-配置描述符"><a href="#3-配置描述符" class="headerlink" title="3. 配置描述符"></a>3. 配置描述符</h2><p>配置描述符定义了设备的配置信息，一个设备可以有多个配置描述符。配置描述符中包括了描述符的长度（属于此描述符的所有接口描述符和端点描述符的长度的和）、供电方式（自供电/总线供电）、最大耗电量等。主机发出 USB 标准命令 Get_Descriptor 要求得到设备的某个配置描述符，那么除了此配置描述符以外，此配置包含的所有接口描述符与端点描述符都将提供给 USB 主机。</p><p>一个 USB 设备可以有多种配置，不同的配置使设备工作在不同的状态下，每个配置必须有一个配置描述符。其格式包括 8 个字段，共 9 字节。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _USB_CONFIGURATION_DESCRIPTOR_<span class="token punctuation">{</span>    BYTE      bLength<span class="token punctuation">,</span>    BYTE      bDescriptorType<span class="token punctuation">,</span>    WORD      wTotalLength<span class="token punctuation">,</span>    BYTE      bNumInterfaces<span class="token punctuation">,</span>    BYTE      bConfigurationValue<span class="token punctuation">,</span>    BYTE      iConfiguration<span class="token punctuation">,</span>    BYTE      bmAttributes<span class="token punctuation">,</span>    BYTE      bMaxPower<span class="token punctuation">}</span>USB_CONFIGURATION_DESCRIPTOR<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">配置描述符长度，配置描述符长度为 9 字节大小。</td></tr><tr><td align="center">bDescriptorType</td><td align="center">描述符类型，配置描述符类型为 0x02。</td></tr><tr><td align="center">wTotalLength</td><td align="center">配置描述符信息总的大小，包括接口描述符、端点描述符等。</td></tr><tr><td align="center">bNumInterfaces</td><td align="center">USB 接口数量。</td></tr><tr><td align="center">bConfigurationValue</td><td align="center">当使用 SetConfiguration 和 GetConfiguration 请求时所指定的配置索引值。</td></tr><tr><td align="center">iConfiguration</td><td align="center">描述配置的字符串描述符索引。</td></tr><tr><td align="center">bmAttributes</td><td align="center">供电配置，位详细定义如下：D7 保留，必须置1；D6 自供电模式；  D5 远程唤醒； D4～D0 保留</td></tr><tr><td align="center">bMaxPower</td><td align="center">最大功耗，以 2mA 为单位，例如 0x32 为 50*2 = 100mA。USB 设备可以从 USB 总线上获得最大的电流为 500mA，因此bMaxPower 字段的最大值可以设置为 250。</td></tr></tbody></table><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20190829154705634.png" alt> </p><h2 id="4-接口描述符"><a href="#4-接口描述符" class="headerlink" title="4.接口描述符"></a>4.接口描述符</h2><p>如果一个配置描述符不止支持一个接口描述符，并且每个接口描述符都有一个或多个端点描述符，那么在响应 USB主机的配置描述符命令时，USB 设备的端点描述符总是紧跟着相关的接口描述符后面，作为配置描述符的一部分被返回。接口描述符不可直接用 Set_Descriptor 和 Get_Descriptor 来存取。若一个接口仅使用端点 0，则接口描述符以后就不再返回端点描述符，并且此接口表现的是一个控制接口的特性，它使用与端点 0 相关联的默认管道进行数据传输。在这种情况下 bNumberEndpoints 域应被设置成 0。接口描述符在说明端点个数并不把端点 0 计算在内。</p><p>接口是端点的集合，负责完成 USB 的特定功能，例如：数据的输入输出。接口描述符用于描述一个接口，包含了接口的特性，如端点个数，所属设备类和子类等。它有 9 个字段，共 9 字节。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _USB_INTERFACE_DESCRIPTOR_<span class="token punctuation">{</span>    BYTE      bLength<span class="token punctuation">,</span>    BYTE      bDescriptorType<span class="token punctuation">,</span>    BYTE      bInterfaceNumber<span class="token punctuation">,</span>    BYTE      bAlternateSetting<span class="token punctuation">,</span>    BYTE      bNumEndpoint<span class="token punctuation">,</span>    BYTE      bInterfaceClass<span class="token punctuation">,</span>    BYTE      bInterfaceSubClass<span class="token punctuation">,</span>    BYTE      bInterfaceProtocol<span class="token punctuation">,</span>    BYTE      iInterface<span class="token punctuation">}</span>USB_INTERFACE_DESCRIPTOR<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">描述符大小．固定为 0x09</td></tr><tr><td align="center">bDescriptorType</td><td align="center">接口描述符类型．固定为 0x04</td></tr><tr><td align="center">bInterfaceNumber</td><td align="center">该接口的编号，接口编号从 0 开始分配，当一个配置有多个接口时，就用该字段来区分不同的接口。</td></tr><tr><td align="center">bAlternateSetting</td><td align="center">用于为上一个字段选择可供替换的位置，即备用的接口描述符标号</td></tr><tr><td align="center">bNumEndpoint</td><td align="center">使用的端点数目．端点 ０ 除外，如果此值为 0 ，此接口仅仅只能被用为控制管道</td></tr><tr><td align="center">bInterfaceClass</td><td align="center">接口所属的类值： 零值为将来的标准保留，如果此域的值设为 FFH，则此接口类由厂商说明，所有其它的值由 USB 说明保留。</td></tr><tr><td align="center">bInterfaceSubClass</td><td align="center">子类码 ：这些值的定义视 bInterfaceClass 域而定。 如果 bInterfaceClass 域的值为零则此域的值必须为零。 bInterfaceClass 域不为 FFH 则所有值由 USB 所保留。</td></tr><tr><td align="center">bInterfaceProtocol</td><td align="center">协议码：bInterfaceClass 和 bInterfaceSubClass 域的值而定.如果一个接口支持设备类相关的请求此域的值指出了设备类说明中所定义的协议.</td></tr><tr><td align="center">iInterface</td><td align="center">描述此接口的字串描述表的索引值。</td></tr></tbody></table><p>接口描述符返回示例：</p><p><img src="https://img-blog.csdnimg.cn/20190829161236757.png" alt>对于 bInterfaceClass 字段，表示接口所属的类别，USB 协议根据功能将不同的接口划分成不的类，其具体含义如下表所示：</p><table><thead><tr><th align="center">值</th><th align="center">类别</th></tr></thead><tbody><tr><td align="center">0x01</td><td align="center">音频类</td></tr><tr><td align="center">0x02</td><td align="center">CDC控制类</td></tr><tr><td align="center">0x03</td><td align="center">人机接口类（HID）</td></tr><tr><td align="center">0x05</td><td align="center">物理类</td></tr><tr><td align="center">0x06</td><td align="center">图像类</td></tr><tr><td align="center">0x07</td><td align="center">打印机类</td></tr><tr><td align="center">0x08</td><td align="center">大数据存储类</td></tr><tr><td align="center">0x09</td><td align="center">集线器类</td></tr><tr><td align="center">0x0A</td><td align="center">CDC数据类</td></tr><tr><td align="center">0x0B</td><td align="center">智能卡类</td></tr><tr><td align="center">0x0D</td><td align="center">安全类</td></tr><tr><td align="center">0xDC</td><td align="center">诊断设备类</td></tr><tr><td align="center">0xE0</td><td align="center">无线控制器类</td></tr><tr><td align="center">0xFE</td><td align="center">特定应用类（包括红外的桥接器等）</td></tr><tr><td align="center">0xFF</td><td align="center">厂商定义的设备</td></tr></tbody></table><h2 id="5-端点描述符"><a href="#5-端点描述符" class="headerlink" title="5.端点描述符"></a>5.端点描述符</h2><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点 0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。</p><p>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为 0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p><p>USB 设备中的每个端点都有自己的端点描述符，由接口描述符中的 bNumEndpoint 决定其数量。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _USB_ENDPOINT_DESCRIPTOR_<span class="token punctuation">{</span>    BYTE        bLength<span class="token punctuation">,</span>    BYTE        bDescriptorType<span class="token punctuation">,</span>    BYTE        bEndpointAddress<span class="token punctuation">,</span>    BYTE        bmAttributes<span class="token punctuation">,</span>    WORD        wMaxPacketSize<span class="token punctuation">,</span>    BYTE        bInterval<span class="token punctuation">}</span>USB_ENDPOINT_DESCRIPTOR<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">描述符大小．固定为 0x07。</td></tr><tr><td align="center">bDescriptorType</td><td align="center">接口描述符类型．固定为 0x05。</td></tr><tr><td align="center">bEndpointAddress</td><td align="center">此描述表所描述的端点的地址、方向： Bit 3..0 : 端点号；Bit 6..4 : 保留,为零 ；Bit 7:    方向，如果控制端点则略。 0：输出端点（主机到设备） ；1：输入端点（设备到主机）</td></tr><tr><td align="center">bmAttributes</td><td align="center">此域的值描述的是在 bConfigurationValue 域所指的配置下端点的特性。 Bit 1..0 :传送类型 （00=控制传送 ；01=同步传送 ；10=批量传送 ；11=中断传送 ，所有其它的位都保留。</td></tr><tr><td align="center">wMaxPacketSize</td><td align="center">当前配置下此端点能够接收或发送的最大数据包的大小。 对于实进传输，此值用于为每帧的数据净负荷预留时间。在实际运行时，管道可能不完全需要预留的带宽，实际带宽可由设备通过一种非 USB 定义的机制汇报给主机。对于中断传输，批量传输和控制传输，端点可能发送比之短的数据包</td></tr><tr><td align="center">bInterval</td><td align="center">周期数据传输端点的时间间隙。 此域的值对于批传送的端点及控制传送的端点无意义。对于同步传送的端点此域必需为 1，表示周期为 1ms。对于中断传送的端点此域值的范围为 1ms 到 255ms。</td></tr></tbody></table><p>端点描述符实例，一个输入、一个输出：</p><p><img src="https://img-blog.csdnimg.cn/20190829170423775.png" alt></p><h2 id="6-字符串描述符"><a href="#6-字符串描述符" class="headerlink" title="6.字符串描述符"></a>6.字符串描述符</h2><p>字符串描述符是一种可选的 USB 标准描述符，描述了如制商、设备名称或序列号等信息。如果一个设备无字符串描述符，则其它描述符中与字符串有关的索引值都必须为 0。字符串使用的是 Unicode 编码。</p><p>主机请示得到某个字符串描述符时一般分成两步：首先主机向设备发出 USB 标准命令 Get_Descriptor，其中所使用的字符串的索引值为 0，设备返回一个字符串描述符，此描述符的结构如下：</p><p><img src="https://img-blog.csdnimg.cn/20190829173517215.png" alt>USB 设备中的字符串可能支持多种语言。请求字符串描述符时，请求者使用 USB-IF 定义的 16 位语ID（LANGID）指定所需的语言。所有语言的字符串索引零都返回一个字符串描述符，该描述符包含设备支持的双字节 LANGID 代码数组。上图表显示了 LANGID 代码数组。 USB 设备可以省略所有字符串描述符。省略所有字符串描述符的 USB 设备不得返回 LANGID 代码数组。</p><p>LANGID 代码数组不以 NULL 结尾。通过从描述符的第一个字节的值中减去两个来计算数组的大小（以字节为单位）。</p><p><strong>UNICODE字符串描述符：</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _USB_STRING_DESCRIPTION_<span class="token punctuation">{</span>    BYTE      bLength<span class="token punctuation">,</span>    BYTE      bDescriptionType<span class="token punctuation">,</span>    BYTE      bString<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>USB_STRING_DESCRIPTION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">描述符大小．由整个字符串的长度加上 bLength 和 bDescriptorType 的长度决定（N+2）</td></tr><tr><td align="center">bDescriptorType</td><td align="center">接口描述符类型．固定为 0x03</td></tr><tr><td align="center">bString</td><td align="center">Unicode 编码字符串（长度为 N）</td></tr></tbody></table><h2 id="7-设备限定描述符"><a href="#7-设备限定描述符" class="headerlink" title="7.设备限定描述符"></a>7.设备限定描述符</h2><p>device_qualifier 描述符描述了有关高速设备的信息，如果设备以其他速度运行，该设备将发生变化。如果设备当前正以全速运行，则 device_qualifier 将返回有关其如何以高速运行的信息。</p><p>标准设备描述符的供应商，产品，设备，制造商，产品和序列号字段不包含在此描述符中，因为该信息对于所有支持的速度的设备是恒定的。 此描述符的版本号必须至少为2.0（0200H）。主机使用GetDescriptor（）请求访问此描述符。</p><p>如果仅全速设备（设备描述符版本号等于0200H）收到对 device_qualifier 的 GetDescriptor（）请求，则它必须响应请求错误。 除非首先成功检索 device_qualifier 描述符，否则主机不得请求 other_speed_configuration 描述符。</p><pre class="line-numbers language-C"><code class="language-C">struct USB_QUALIFIER_DESCRIPTOR {    BYTE  bLength;    BYTE  bDescriptorType;    WORD bcdUSB;    BYTE  bDeviceClass;    BYTE  bDeviceSubClass;    BYTE  bDeviceProtocol;    BYTE  bMaxPacketSize0;    BYTE  bNumConfigurations;    BYTE  bRESERVED;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">字段名</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bLength</td><td align="center">设备限定描述符长度，10 个字节（0AH）</td></tr><tr><td align="center">bDescriptorType</td><td align="center">限定描述符类型，固定为 06H</td></tr><tr><td align="center">bcdUSB</td><td align="center">USB 设备及其描述符遵循的 USB 规范版本号，以 BCD 码形式表示，版本必须在  2.0 以上</td></tr><tr><td align="center">bDeviceClass</td><td align="center">USB 所属的设备类</td></tr><tr><td align="center">bDeviceSubClass</td><td align="center">USB 所属的设备子类，设备类再细分</td></tr><tr><td align="center">bDeviceProtocol</td><td align="center">协议代码（由USB分配），如果使用 USB-IF 组织定义的协议，就需要设置这里的值，否则直接设置为  0。如果厂商自己定义的可以设置为 FFH</td></tr><tr><td align="center">bMaxPacketSize0</td><td align="center">端点 ０ 最大分组大小（只有 8,16,32,64 有效）,对于低速 USB 设备，bMaxPacketSize0 为8；对于全速 USB 设备，bMaxPacketSize0 为 8、16、32、64；对于高速 USB 设备，bMaxPacketSize0 为 64。</td></tr><tr><td align="center">bNumConfigurations</td><td align="center">表示 USB 设备另一个速率所支持的配置数</td></tr><tr><td align="center">bRESERVED</td><td align="center">保留项，置0</td></tr></tbody></table><p>注：此处针对 USB2.0 协议</p><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1.<a href="https://blog.csdn.net/qq_16777851/article/details/85222030" target="_blank" rel="noopener">从零开始学USB（十、USB的描述符）</a><br>2.<a href="https://blog.csdn.net/mcgrady_tracy/article/details/8129992" target="_blank" rel="noopener">USB描述符</a><br>3.<a href="https://blog.csdn.net/alien75/article/details/4622319" target="_blank" rel="noopener">USB描述符详解</a><br>4.<a href="http://usb.baiheee.com/usb_article/usb_spec/usb_cmd_desc.html" target="_blank" rel="noopener">USB命令请求及描述符详解（速查手册）</a><br>5.<a href="https://blog.csdn.net/wavemcu/article/details/7220697" target="_blank" rel="noopener">USB中的描述符详解 一</a><br>6.<a href="https://blog.csdn.net/yuesichiu/article/details/71266179" target="_blank" rel="noopener">USB请求和USB描述符</a><br>7.<a href="https://blog.csdn.net/qq_16777851/article/details/85222030" target="_blank" rel="noopener">从零开始学USB（十、USB的描述符）</a></p>]]></content>
      
      
      <categories>
          
          <category> USB 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> USB </tag>
            
            <tag> Mass Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB总线专题（四）——枚举过程</title>
      <link href="/2019/09/06/usb-zong-xian-zhuan-ti-si-mei-ju-guo-cheng/"/>
      <url>/2019/09/06/usb-zong-xian-zhuan-ti-si-mei-ju-guo-cheng/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p> 枚举就是从设备读取一些信息，知道设备是什么样的设备，如何进行通信，这样主机就可以根据这些信息来加载合适的驱动程序。枚举过程包括设备地址的分配，从设备读取设备描述符，分配加载驱动程序，选择规定的设备功耗要求和接口配置信息。</p><p>USB 架构中， hub 负责检测设备的连接和断开，利用其中断 IN 端点 (Interrupt IN Endpoint) 来向主机（Host）报告。在系统启动时，主机轮询它的根 hub（Root Hub）的状态看是否有设备（包括子hub和子hub上的设备）连接。 只要检测到有新设备连接上来，主机就会发送一系列的请求 (Resqusts) 给设备所挂载到的 hub，再由 hub 建立起一条连接主机（Host）和设备（Device）之间的通信通道。然后主机以控制传输 (Control Transfer) 的方式，通过端点0 (Endpoint 0) 对设备发送各种请求，设备收到主机发来的请求后回复相应的信息，进行枚举（Enumerate）操作。所有的 USB 设备必须支持标准请求（Standard Requests），控制传输方式（Control Transfer）和端点0（Endpoint 0）。</p><h2 id="2-设备状态"><a href="#2-设备状态" class="headerlink" title="2. 设备状态"></a>2. 设备状态</h2><p>USB 协议定义了设备的 6 种状态，仅枚举过程，设备就经历了 4 个状态的迁移：上电状态 ( Powered)，默认状态 (Default)，地址状态 (Address) 和配置状态 (Configured)（其他两种是连接状态（Attached）和挂起状态（Suspend）。</p><p><img src="https://img-blog.csdnimg.cn/20190905111144484.png" alt></p><h3 id="2-1-连接-Attached"><a href="#2-1-连接-Attached" class="headerlink" title="2.1 连接(Attached)"></a>2.1 连接(Attached)</h3><p>设备可以连接到 USB 或者从 USB 上拔出。设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入。</p><h3 id="2-2上-电-Powered"><a href="#2-2上-电-Powered" class="headerlink" title="2.2上 电(Powered)"></a>2.2上 电(Powered)</h3><p> USB 设备的电源可来自外部电源，也可从 USB 接口的集线器而来。电源来自外部电源的 USB 设备被称作自给电源式的 (self-powered)。尽管自给电源式的 USB 设备可能在连接上 USB 接口以前可能已经带电，但它们直到连线上 USB 接口后才能被看作是加电状态 (Powered state)，这时候 VBUS 已经对设备产生作用了。</p><p>一个设备可能有既支持自给电源的，同时也支持总线电源式的配置。有一些支持其中的一种，而另一些设备配置可能只有在自给电源下才能被使用。设备对电源支持的能力是通过配置描述表 (configuration descriptor) 来反映的。当前的电源供给形式被作为设备状态的一部分被反映出来。设备可在任何时候改变它们的供电来源，比如说：从自给式向总线式改变，如果一个配置同时支持两种模式，那此状态的最大电源需求就是指设备在两种模式下从 VBUS 上获取电能的最大值。设备必须以此最大电源作为参照，而究竟处于何状态是不考虑的。如果有一配置仅支持一种电源模式，那么电源模式的改变会使得设备失去当前配置与地址，返回加电状态。如果一个设备是自给电源式，并且当前配置需要大于 100mA 电流，那么如果此设备转到了总线电源式，它必须返回地址状态 (Address state)。自给电源式集线器使用 VBUS 来为集线控制器 (Hub controller) 提供电源，因而可以仍然保持配置状态 (Configured state)，尽管自给电源停止提供电源。</p><h3 id="2-3-默认状态-Default"><a href="#2-3-默认状态-Default" class="headerlink" title="2.3 默认状态(Default)"></a>2.3 默认状态(Default)</h3><p>设备上电后，它不响应任何总线处理，直到总线接收到复位信号为止。接收到复位信号后，用默认的地址可以对设备寻址。</p><p>当用复位过程完成后，USB 设备在正确的速度下操作(即低速/全速/高速)。低速和全速的数据选择由设备的终端电阻决定，能进行高速操作的设备决定它是否在复位的过程的一部分执行高速操作。</p><p>能进行高速操作的设备在全速的电气环境中操作时，必须能以全速成功复位，设备成功复位后，设备必须成功响应设备和配置描述符请求，并且返回适当的信息。当在全速下工作时，设备可能或者不能支持预定义的功能。</p><h3 id="2-4-地址-Address"><a href="#2-4-地址-Address" class="headerlink" title="2.4 地址(Address)"></a>2.4 地址(Address)</h3><p>所有的 USB 设备在加电复位以后都使用缺省地址，每一设备在连接或复位后由主机分配一个唯一的地址。当 USB 设备处于挂起状态时，它保持这个地址不变。 USB 设备只对缺省通道  (Pipe)  请求发生响应，而不管设备是否已经被分配地址或在使用缺省地址。</p><p>主控制器分配从设备设备的设备地址。范围为 0 – 127。包格式 ”00 05 XX XX 00 00 00 00”，其中 XX XX 为 2 字节设备地址，地址范围 0 – 128。</p><p><img src="https://img-blog.csdnimg.cn/20190911190223246.png" alt></p><h3 id="2-5-配置状态-Configured"><a href="#2-5-配置状态-Configured" class="headerlink" title="2.5 配置状态( Configured )"></a>2.5 配置状态( Configured )</h3><p>在 USB 设备正常工作以前，设备必须被正确配置。从设备的角度来看，配置包括一个将非零值写入设备配置寄存器的操作。配置一个设备或改变一个可变的设备设置，将会使得与这个相关接口的终端结点的所有的状态与配置值被设成缺省值。这包括将正在使用 (date toggle) 的端点 (end point) 的 (Date toggle) 被设置成DATA0。</p><h3 id="2-6-挂起状态（Suspended）"><a href="#2-6-挂起状态（Suspended）" class="headerlink" title="2.6 挂起状态（Suspended）"></a>2.6 挂起状态（Suspended）</h3><p>为节省电源，USB 设备在探测不到总线传输时自动进入中止状态。当中止时，USB 设备保持本身的内部状态，包括它的地址及配置。</p><p>所有的设备在一段特定的时间内探测不到总线活动时必须进入中止态。不管设备是被分配了非缺省的地址或者是被配置了，已经连接的设备必须在任何加电的时刻随时准备中止。总线活动的中止可能是因为主机本身进入了中止状态。另外，USB 设备必须在所连接的集线器端口失效时进入中止态。这就是所指的选择性中止 (Selective suspend)。</p><p>USB 设备在总线活动来到时结束中止态。USB 设备也可以远程唤醒的电流信号来请求主机退出中止态或选择性中止态。具体设备具有的远程唤醒的能力是可选的，也就是说，如果一个设备有远程唤醒的能力，此设备必须能让主机控制此能力的有效与否，当设备复位时，远程唤醒能力必须被禁止。</p><h2 id="3-枚举步骤"><a href="#3-枚举步骤" class="headerlink" title="3. 枚举步骤"></a>3. 枚举步骤</h2><p>整体步骤如下图： 通过 USB 协议分析仪抓取。</p><p><img src="https://img-blog.csdnimg.cn/20190910094410470.png" alt></p><h3 id="3-1-USB-设备插入端口或给系统启动时设备上电"><a href="#3-1-USB-设备插入端口或给系统启动时设备上电" class="headerlink" title="3.1  USB 设备插入端口或给系统启动时设备上电"></a>3.1  USB 设备插入端口或给系统启动时设备上电</h3><p>指的 USB 端口指的是主机下的根 hub 或主机下行端口上的 Hub 端口。Hub 给端口供电，连接着的设备处于上电状态。此时，USB 设备处于加电状态，它所连接的端口是无效的。</p><p><img src="https://img-blog.csdnimg.cn/20190910094759181.png" alt></p><h3 id="3-2-Hub监测各个端口数据线上-D-D-的电压"><a href="#3-2-Hub监测各个端口数据线上-D-D-的电压" class="headerlink" title="3.2 Hub监测各个端口数据线上(D+/D-)的电压"></a>3.2 Hub监测各个端口数据线上(D+/D-)的电压</h3><p>在 hub 端，数据线 D+ 和 D- 都有一个阻值在 14.25K 到 24.8K 的下拉电阻 Rpd（一般设置为 15K ），而在设备端，D+（全速，高速）和 D-（低速）上有一个 1.5K 的上拉电阻 Rpu。当设备插入到 hub 端口时，有上拉电阻的一根数据线被拉高到幅值的 90%的电压（大约 3V）。hub 检测到它的一根数据线是高电平，就认为是有设备插入，并能根据是 D+ 还是 D- 被拉高来判断到底是什么设备（全速/低速）插入端口（高速设备先识别书全速，然后再进一步协商确定为高速）。当 USB 设备上电后，一直监测 USB 设备接口电平变化 HUB 检测到有电压变化，将利用自己的中断端点将信息反馈给主控制器有设备连接。</p><h3 id="3-3-Host-了解连接的设备"><a href="#3-3-Host-了解连接的设备" class="headerlink" title="3.3 Host 了解连接的设备"></a>3.3 Host 了解连接的设备</h3><p>每个 hub 利用它的中断端点向主机报告它的各个端口的状态（对于这个过程，设备是看不到的，也不关心），报告的内容只是 hub 端口的设备连接或断开的事件。如果有连接或断开事件发生，那么 Host 会发送一个 Get_Port_Status 请求 (request) 给 hub 以了解此次状态改变的确切含义。Get_Port_Status 等请求属于所有 hub 都要求支持的 hub 类标准请求。</p><h3 id="3-4-Hub-检测所插入的设备是高速还是低速设备"><a href="#3-4-Hub-检测所插入的设备是高速还是低速设备" class="headerlink" title="3.4 Hub 检测所插入的设备是高速还是低速设备"></a>3.4 Hub 检测所插入的设备是高速还是低速设备</h3><p>hub 通过检测 USB 总线空闲 (Idle) 时差分线的高低电压来判断所连接设备的速度类型，当 host 发来 Get_Port_Status 请求时，hub 就可以将此设备的速度类型信息回复给 host。USB 2.0 规范要求速度检测要先于复位（Reset）操作。</p><p><img src="https://img-blog.csdnimg.cn/20190910094912860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><h3 id="3-5-hub复位设备"><a href="#3-5-hub复位设备" class="headerlink" title="3.5  hub复位设备"></a>3.5  hub复位设备</h3><p>Host 一旦得知新设备已连上以后，它至少等待 100ms 以使得插入操作的完成以及设备电源稳定工作。然后主机控制器就向 hub 发出一个 Set_Port_Feature 请求让 hub 复位其管理的端口 (刚才设备插上的端口)。hub 通过驱动数据线到复位状态( D+ 和 D- 全为低电平 )，并持续至少 10ms。当然，hub 不会把这样的复位信号发送给其他已有设备连接的端口，故其他连在该 hub上的设备自然看不到复位信号，不受影响。</p><h3 id="3-6-Host检测所连接的全速设备是否是支持高速模式"><a href="#3-6-Host检测所连接的全速设备是否是支持高速模式" class="headerlink" title="3.6 Host检测所连接的全速设备是否是支持高速模式"></a>3.6 Host检测所连接的全速设备是否是支持高速模式</h3><p>根据 USB 2.0 协议，高速（High Speed）设备在初始时是默认全速（Full Speed ）状态运行，对于一个支持 USB 2.0 的高速 hub，当它发现它的端口连接的是一个全速设备时，会进行高速检测，看看目前这个设备是否还支持高速传输，如果是，那就切到高速信号模式，否则就一直在全速状态下工作。</p><p>从设备的角度来看，如果是一个高速设备，在刚连接 hub 或上电时只能用全速信号模式运行（根据 USB 2.0 协议，高速设备必须向下兼容 USB 1.1 的全速模式）。随后 hub 会进行高速检测，之后这个设备才会切换到高速模式下工作。若连接的 hub 不支持 USB 2.0，即不是高速 hub，不能进行高速检测，设备将一直以全速工作。</p><p><img src="https://img-blog.csdnimg.cn/20190910095844296.png" alt></p><h3 id="3-7-Hub建立设备和主机之间的信息通道"><a href="#3-7-Hub建立设备和主机之间的信息通道" class="headerlink" title="3.7 Hub建立设备和主机之间的信息通道"></a>3.7 Hub建立设备和主机之间的信息通道</h3><p>主机不停地向 hub 发送 Get_Port_Status 请求，以查询设备是否复位成功。Hub 返回的报告信息中有专门的一位用来标志设备的复位状态。</p><p>当 hub 撤销了复位信号，设备就处于默认或空闲状态，准备接收主机发来的请求。设备和主机之间的通信通过控制传输，默认地址 0，端点号 0 进行。此时，设备能从总线上得到的最大电流是 100mA。所有的 USB 设备在总线复位后其地址都为 0，这样主机就可以跟那些刚刚插入的设备通过地址 0 通信。</p><h3 id="3-8-主机发送Get-Descriptor-请求获取默认管道的最大包长度"><a href="#3-8-主机发送Get-Descriptor-请求获取默认管道的最大包长度" class="headerlink" title="3.8 主机发送Get_Descriptor 请求获取默认管道的最大包长度"></a>3.8 主机发送Get_Descriptor 请求获取默认管道的最大包长度</h3><p>默认管道（Default Pipe）在设备一端来看就是端点 0。主机此时发送的请求是默认地址 0，端点 0，虽然所有未分配地址的设备都是通过地址 0 来获取主机发来的请求，但由于枚举过程不是多个设备并行处理，而是一次枚举一个设备的方式进行，所以不会发生多个设备同时响应主机发来的请求。</p><p><img src="https://img-blog.csdnimg.cn/20190910100742642.png" alt></p><p> 设备描述符的第 8 字节代表设备端点 0 的最大包大小。虽然说设备所返回的设备描述符（Device Descriptor）长度只有 18 字节，但系统也不在乎（枚举过程中第一次获取设备描述符）。此时，描述符的长度信息对它来说是最重要的。当完成第一次的控制传输后，也就是完成控制传输的状态阶段，系统会要求 hub 对设备进行再一次的复位操作（USB 规范里面可没这要求），再次复位的目的是使设备进入一个确定的状态。</p><h3 id="3-9-主机给设备分配一个地址"><a href="#3-9-主机给设备分配一个地址" class="headerlink" title="3.9 主机给设备分配一个地址"></a>3.9 主机给设备分配一个地址</h3><p>主机控制器通过 Set_Address 请求向设备分配一个唯一的地址。在完成这次传之后，设备进入地址状态（Address state），之后就启用新地址继续与主机通信。这个地址对于设备来说是终生制的，设备在，地址在；设备消失（被拔出，复位，系统重启），地址被收回。同一个设备当再次被枚举后得到的地址不一定是上次那个了，经历这些状态设备将重复枚举的过程。</p><p><img src="https://img-blog.csdnimg.cn/20190910103126682.png" alt></p><h3 id="3-10-主机获取设备的信息"><a href="#3-10-主机获取设备的信息" class="headerlink" title="3.10 主机获取设备的信息"></a>3.10 主机获取设备的信息</h3><p>主机再次发送 Get_Descriptor 请求到新地址读取设备描述符，这次主机发送Get_Descriptor 请求会返回整个设备描述符信息，18 字节的长度，它会认真解析设备描述符的内容。设备描述符内信息包括端点 0 的最大包长度，设备所支持的配置（Configuration）个数，设备类型，VID（Vendor ID，由USB-IF分配）， PID（Product ID，由厂商自己定制）等信息。</p><p>获取完整的设备描述符：</p><p><img src="https://img-blog.csdnimg.cn/20190910103905330.png" alt></p><p>获取配置描述符：</p><p><img src="https://img-blog.csdnimg.cn/20190910104529507.png" alt></p><h3 id="3-11-主机给设备挂载驱动（复合设备除外）"><a href="#3-11-主机给设备挂载驱动（复合设备除外）" class="headerlink" title="3.11 主机给设备挂载驱动（复合设备除外）"></a>3.11 主机给设备挂载驱动（复合设备除外）</h3><p>主机通过解析描述符后对设备有了足够的了解，会选择一个最合适的驱动给设备。  然后 announce_device 说明设备已经找到了，最后调用设备模型提供的接口 device_add 将设备添加到 usb 总线的设备列表里，然后 usb 总线会遍历驱动列表里的每个驱动，调用自己的 match（usb_device_match） 函数看它们和设备或接口是否匹配，匹配的话调用 device_bind_driver 函数，现在就将控制权交到设备驱动了。   </p><p>对于复合设备，通常应该是不同的接口（Interface）配置给不同的驱动，因此，需要等到当设备被配置并把接口使能后才可以把驱动挂载上去。</p><h3 id="3-12-设备驱动选择一个配置"><a href="#3-12-设备驱动选择一个配置" class="headerlink" title="3.12 设备驱动选择一个配置"></a>3.12 设备驱动选择一个配置</h3><p>驱动（之后的事情都是有驱动来接管负责与设备的通信）根据前面设备回复的信息，发送 Set_Configuration 请求来正式确定选择设备的哪个配置（Configuration）作为工作配置（对于大多数设备来说，一般只有一个配置被定义）。至此，设备处于配置状态 (Configured)，当然，设备也应该使能它的各个接口（Interface）。对于复合设备，主机会在这个时候根据设备接口信息，给它们挂载驱动。</p><p>获取设备状态：</p><p><img src="https://img-blog.csdnimg.cn/20190910110855695.png" alt></p><p>主机指示设备采用的要求的配置：</p><p><img src="https://img-blog.csdnimg.cn/20190910111715248.png" alt></p><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1.<a href="https://blog.csdn.net/MyArrow/article/details/8270029" target="_blank" rel="noopener">USB枚举过程</a><br>2.<a href="https://blog.csdn.net/qq_16777851/article/details/85712751" target="_blank" rel="noopener">从零开始学USB（十五、USB的设备状态）</a><br>3.<a href="http://www.lnsign.com/2018/03/02/usb-enum-detial-analysis/#1.1" target="_blank" rel="noopener">详细分析USB枚举过程(HID键盘)</a></p>]]></content>
      
      
      <categories>
          
          <category> USB 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> USB </tag>
            
            <tag> Mass Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习笔记一一HEX文件和BIN文件格式</title>
      <link href="/2019/08/11/stm32-xue-xi-bi-ji-yi-yi-hex-wen-jian-he-bin-wen-jian-ge-shi/"/>
      <url>/2019/08/11/stm32-xue-xi-bi-ji-yi-yi-hex-wen-jian-he-bin-wen-jian-ge-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>今天看串口的 IAP ，平时我们通过 JTAG 等工具下载的都是 HEX 文件，都没有思考一下 HEX 的文件组成。而串口 IAP 下载的是 BIN 文件，刚好在这里区分学习一下。</p><p>我们平时烧写 HEX 文件是不需要设置地址信息的，因为已经包含在文件里面，而使用 BIN 烧写，需要在程序中指定地址。</p><p><img src="https://img-blog.csdnimg.cn/20181106112107739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><h2 id="2-简述"><a href="#2-简述" class="headerlink" title="2. 简述"></a>2. 简述</h2><p>Intel hex 文件是记录文本行的 ASCII 文本文件，在 Intel HEX 文件中，每一行是一个 HEX 记录，由十六进制数组成的机器码或者数据常量。Intel HEX 文件经常被用于将程序或数据传输存储到 ROM、EPROM，大多数编程器和模拟器使用Intel HEX文件。</p><h4 id="2-1-HEX文件"><a href="#2-1-HEX文件" class="headerlink" title="2.1 HEX文件"></a>2.1 HEX文件</h4><p>HEX 文件是<strong>包括地址信息的，而BIN文件格式只包括了数据本身</strong>。在烧写或下载HEX文件的时候，一般都不需要用户指定地址，因为HEX文件内部的信息已经包括了地址。而烧写BIN文件的时候，用户是一定需要指定地址信息的。</p><h4 id="2-2-BIN文件"><a href="#2-2-BIN文件" class="headerlink" title="2.2 BIN文件"></a>2.2 BIN文件</h4><p> 对二进制文件而言，其实没有”格式”。文件只是包括了纯粹的二进制数据。</p><h4 id="2-3-HEX文件格式"><a href="#2-3-HEX文件格式" class="headerlink" title="2.3 HEX文件格式"></a>2.3 HEX文件格式</h4><p> HEX文件都是由记录（RECORD）组成的。在HEX文件里面，每一行代表一个记录。记录的基本格式为：</p><p><img src="https://img-blog.csdnimg.cn/2018110610362726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><p>RECTYP类型：</p><p><img src="https://img-blog.csdnimg.cn/20181106104549605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><p>eg:</p><p><img src="https://img-blog.csdnimg.cn/20181106104238796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><p>第一条：</p><p>RECLEN：02；OFFSET：0000；RECTYP：04；INFO or DATA：0000；CHKUSM：FA</p><p>第二条：</p><p>RECLEN：10；OFFSET：0000；RECTYP：00；INFO or DATA：982100203501000021920000A5920000；CHKUSM：F7</p><p>以此类推</p><p><img src="https://img-blog.csdnimg.cn/20181106105053464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><p><strong>最后一条，表示文件末尾：:00000001FF</strong></p><h4 id="2-4-BIN文件格式"><a href="#2-4-BIN文件格式" class="headerlink" title="2.4 BIN文件格式"></a>2.4 BIN文件格式</h4><p><img src="https://img-blog.csdnimg.cn/20181106105336517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dDE4ODExNzA3OTcx,size_16,color_FFFFFF,t_70" alt></p><p>可以看到，BIN文件的数据与 HEX 格式数据的数据段是一一对应的。</p><h4 id="2-5-HEX与BIN文件的大小"><a href="#2-5-HEX与BIN文件的大小" class="headerlink" title="2.5 HEX与BIN文件的大小"></a>2.5 HEX与BIN文件的大小</h4><p>HEX 文件是用 ASCII 来表示二进制的数值。<br>例如：一般 8BIT 的二进制数值0x3F，用ASCII来表示就需要分别表示字符’3’ 和字符’F’，每个字符需要一个BYTE，所以HEX文件需要 &gt; 2倍的空间。</p><p>对一个BIN文件而言，文件的大小就是文件包括的数据的实际大小。而对HEX文件而言，看到的文件大小并不是实际的数据的大小：一是因为HEX文件是用ASCII来表示数据，二是因为HEX文件本身还包括别的附加信息。</p><h4 id="2-6-校验和计算"><a href="#2-6-校验和计算" class="headerlink" title="2.6 校验和计算"></a>2.6 校验和计算</h4><p>计算从(0x3a–”:”)以后的所有各字节的和模256的余。即各字节二进制算术和，不计超过256的溢出值，然后用0x100减去这个算数累加和，得出的值就是此行校验码。</p><p>eg：04000005000000C92E<br>0x100-(04+00+00+05+00+00+00+C9) = 2E</p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p><hr><p><strong>参考：</strong></p><p>1.<a href="http://www.cnblogs.com/skullboyer/p/7978189.html" target="_blank" rel="noopener">hex和bin文件格式的区别</a></p><p>2.<a href="http://www.openedv.com/forum.php?mod=viewthread&tid=7621&highlight=bin%2Bhex" target="_blank" rel="noopener">HEX文件和BIN文件格式的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEX </tag>
            
            <tag> BIN </tag>
            
            <tag> Debug </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于迅为itop4412开发板的4G模块SIM7100的拨号上网的实现</title>
      <link href="/2016/08/13/ji-yu-xun-wei-itop4412-kai-fa-ban-de-4g-mo-kuai-sim7100-de-bo-hao-shang-wang-de-shi-xian/"/>
      <url>/2016/08/13/ji-yu-xun-wei-itop4412-kai-fa-ban-de-4g-mo-kuai-sim7100-de-bo-hao-shang-wang-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><pre><code>    实现4G模块sim7100在Linux系统上的拨号上网。</code></pre><hr><h2 id="二、实验平台："><a href="#二、实验平台：" class="headerlink" title="二、实验平台："></a>二、实验平台：</h2><p>开发板：迅为4412精英版；4G模块：SIM7100开发板。SIM7100C带有USB口和串口，考虑速率等问题，采用USB接口与开发板相连接。我的4412开发板运行的是Linux最小系统，我们需要向内核添加4G模块的驱动与PPP协议支持，然后在编译内核下载到开发板。</p><hr><h2 id="三、实验流程"><a href="#三、实验流程" class="headerlink" title="三、实验流程"></a>三、实验流程</h2><h4 id="1、内核配置：源码目录，通过mkae-menuconfig进入配置。"><a href="#1、内核配置：源码目录，通过mkae-menuconfig进入配置。" class="headerlink" title="1、内核配置：源码目录，通过mkae menuconfig进入配置。"></a>1、内核配置：源码目录，通过mkae menuconfig进入配置。</h4><h6 id="（1）大容量存储驱动"><a href="#（1）大容量存储驱动" class="headerlink" title="（1）大容量存储驱动"></a>（1）大容量存储驱动</h6><p> Device Drivers &gt; USB support</p><p>make ARCH=arm menuconfig配置USB驱动：</p><p>&lt;*&gt;    USB Mass Storage support</p><p>[*]      USB Mass Storage verbose debug</p><p>&lt;*&gt;      Realtek Card Reader support</p><p>[*]        Realtek Card Reader autosuspend support</p><p>&lt;*&gt;      Datafab Compact Flash Reader support</p><h6 id="（2）USB驱动"><a href="#（2）USB驱动" class="headerlink" title="（2）USB驱动"></a>（2）USB驱动</h6><blockquote><p>Device Drivers &gt; USB support</p></blockquote><p>&lt;*&gt;  Inventra Highspeed Dual Role Controller (TI, ADI, …)   </p><pre><code>        MUSB Mode Selection (Dual Role mode)  ---&gt;            &lt;*&gt;    Platform Glue Layer (TI DSPS platforms)  ---&gt;             MUSB DMA mode (Disable DMA (always use PIO))  ---&gt;</code></pre><p>&lt;*&gt;  USB Serial Converter support  —&gt;</p><p>[*]      USBGeneric Serial Driver </p><p>&lt;*&gt;     USBdriver for GSM and CDMA modems</p><h6 id="（3）PPP驱动"><a href="#（3）PPP驱动" class="headerlink" title="（3）PPP驱动"></a>（3）PPP驱动</h6><blockquote><p>Device Drivers &gt; Network device support</p></blockquote><p>  &lt;*&gt;  PPP (point-to-point protocol) support         </p><pre><code>&lt;*&gt;    PPP BSD-Compress compression                         &lt;*&gt;    PPP Deflate compression                             [*]    PPP filtering                                           &lt;*&gt;    PPP MPPE compression (encryption)                          [*]    PPP multilink support                 &lt;*&gt;    PPP over Ethernet               &lt;*&gt;    PPP support for async serial ports   &lt;*&gt;    PPP support for sync tty ports     </code></pre><p>&lt;*&gt;  SLIP (serial line) support     </p><p>[*]  CSLIP compressed headers</p><p>全部添加进入内核后，使用make编译，编译出来的zImage烧写到开发板。（注：zImage目录：源码的arch/arm/boot/目录下）</p><hr><h4 id="2、交叉编译libusb"><a href="#2、交叉编译libusb" class="headerlink" title="2、交叉编译libusb"></a>2、交叉编译libusb</h4><pre><code>这部分为提供USB支持，这一部分我是参考下面的连接：</code></pre><p>[libusb交叉编译] (<a href="http://www.linuxidc.com/Linux/2016-03/129581.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-03/129581.htm</a>)</p><p>编译成功后，将生成的libusb-1.0.20和libusb-compat-0.1.5下的库文件(lib下的文件)复制到ARM板上的linux的/lib下面即可。（我这里是最小系统下的lib下如下图：（可以直接复制过去；也可以通过先放到最小系统的lib下，直接压缩到system.ing文件中，再下载到板子上）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkxNjI2NTg2?x-oss-process=image/format,png" alt></p><hr><h4 id="3、交叉编译4G模块驱动：Gobiserial-ko"><a href="#3、交叉编译4G模块驱动：Gobiserial-ko" class="headerlink" title="3、交叉编译4G模块驱动：Gobiserial.ko"></a>3、交叉编译4G模块驱动：Gobiserial.ko</h4><p>我觉得这个驱动是很重要的，厂家提供的资料里竟然没有。最终在谷歌上找到了。亲测可用[下载连接]</p><p> (<a href="http://www.reyax.com/httpdocs/index.files/4G_Module.htm" target="_blank" rel="noopener">http://www.reyax.com/httpdocs/index.files/4G_Module.htm</a>)</p><p> 具体的操作为：将压缩包复制到ubuntu下，解压，</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyMzQxMDQy?x-oss-process=image/format,png" alt></p><p> 进入到Gobiserial文件夹，把Makefile文件的源码目录替换为我们自己的（编我直接使用的是编译驱动写的），然后make</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyNTA4NzUy?x-oss-process=image/format,png" alt></p><p> 就可以得到驱动文件Gobiserial.ko文件</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyNTM1NDg3?x-oss-process=image/format,png" alt></p><p> 将此.ko文件拷贝到U盘或者开发板上均可。至此驱动方面的工作就完毕了！！！</p><hr><h4 id="4、加载驱动"><a href="#4、加载驱动" class="headerlink" title="4、加载驱动"></a>4、加载驱动</h4><p>我将Gobiserial.ko文件复制到了开发板的/bin/目录下</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyNzU2NDc0?x-oss-process=image/format,png" alt></p><p>通过加载驱动的命令:insmod Gobiserial.ko 将驱动插入到内核中</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyODIyODk3?x-oss-process=image/format,png" alt></p><p> 查看此模块是否成功插入：lsmod</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyODU2NzAw?x-oss-process=image/format,png" alt></p><p> 成功插入驱动后；插入4G模块，虚拟出6个ttyUSB，它们分别是：</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkyOTMzODY3?x-oss-process=image/format,png" alt></p><p> 具体的作用为：</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzMDAwMDA4?x-oss-process=image/format,png" alt></p><hr><h4 id="5、交叉编译PPP"><a href="#5、交叉编译PPP" class="headerlink" title="5、交叉编译PPP"></a>5、交叉编译PPP</h4><p> 这个参考: [PPP编译] (<a href="http://www.linuxidc.com/Linux/2016-03/129580.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-03/129580.htm</a>)</p><p> 我下载的是ppp-2.4.7，复制到ubuntu下，解压, 编译：</p><h6 id="（1）生成Makefile文件（也可直接-configure）"><a href="#（1）生成Makefile文件（也可直接-configure）" class="headerlink" title="（1）生成Makefile文件（也可直接./configure）"></a>（1）生成Makefile文件（也可直接./configure）</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNDA2NzM0?x-oss-process=image/format,png" alt></p><h6 id="2-编译（必须使用与开发板一致的编译器，迅为的4412用的是arm-2009q3）"><a href="#2-编译（必须使用与开发板一致的编译器，迅为的4412用的是arm-2009q3）" class="headerlink" title="(2)编译（必须使用与开发板一致的编译器，迅为的4412用的是arm-2009q3）"></a>(2)编译（必须使用与开发板一致的编译器，迅为的4412用的是arm-2009q3）</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNDU3MDAw?x-oss-process=image/format,png" alt></p><h6 id="（3）编译命令："><a href="#（3）编译命令：" class="headerlink" title="（3）编译命令："></a>（3）编译命令：</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNTM1NzY3?x-oss-process=image/format,png" alt></p><h6 id="4-安装：make-install-（有错，不用管）"><a href="#4-安装：make-install-（有错，不用管）" class="headerlink" title="(4)安装：make install （有错，不用管）"></a>(4)安装：make install （有错，不用管）</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNTU5NjA5?x-oss-process=image/format,png" alt></p><h6 id="5-将编译出来的脚本复制到ARM开发板上："><a href="#5-将编译出来的脚本复制到ARM开发板上：" class="headerlink" title="(5)将编译出来的脚本复制到ARM开发板上："></a>(5)将编译出来的脚本复制到ARM开发板上：</h6><p>按照上面的make好之后，由于make install出错，所以直接在目录中找到如下的四个文件：</p><p>chat  pppd  pppdump  pppstats</p><p>复制到ARM开发板的/usr/sbin目录下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNjQxODE1?x-oss-process=image/format,png" alt></p><h6 id="6-建立-etc-ppp目录："><a href="#6-建立-etc-ppp目录：" class="headerlink" title="(6)建立/etc/ppp目录："></a>(6)建立/etc/ppp目录：</h6><p>从ppp-2.4.7相应目录中拷贝文件，建立如下目录结构：<br>注：前两个文件我是从ppp-2.4.7目录下拷贝的，另外的没找到，直接到/etc/ppp目录下复制：</p><p>/etc/ppp/chap-secrets<br>/etc/ppp/pap-secrets<br>/etc/ppp/ip-up<br>/etc/ppp/ip-down<br>/etc/ppp/peers/</p><p>拷贝之后放到开发板的对应目录下：如下图所示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTkzNzIzODI5?x-oss-process=image/format,png" alt></p><p>至此，ppp编译顺利完成！！！！</p><hr><h4 id="5-拨号脚本设置"><a href="#5-拨号脚本设置" class="headerlink" title="(5)拨号脚本设置"></a>(5)拨号脚本设置</h4><h6 id="（1）a-在-etc-ppp目录下使用-vi-gprs-connect-chat-建立文件"><a href="#（1）a-在-etc-ppp目录下使用-vi-gprs-connect-chat-建立文件" class="headerlink" title="（1）a.在/etc/ppp目录下使用 vi gprs-connect-chat 建立文件"></a>（1）a.在/etc/ppp目录下使用 vi gprs-connect-chat 建立文件</h6><p>内容如下：</p><pre><code>#/etc/ppp/gprs-connect-chat# chat script for China Mobile, used in SIMCOM sim4100 TD module.</code></pre><p>TIMEOUT 15<br>ABORT “DELAYED”<br>ABORT “BUSY”<br>ABORT “ERROR”<br>ABORT “NO DIALTONE”<br>ABORT “NO CARRIER”<br>TIMEOUT 40<br>‘’ \rAT<br>OK ATS0=0<br>OK ATE0V1<br>OK AT+CGDCONT=1,”IP”,”CMNET”<br>OK AT+CGEQREQ=1,2,128,384,,,0,,,,,,<br>OK ATDT<em>99</em>1#<br>CONNECT<br>保存之后，退出</p><h6 id="2-进入-etc-ppp-peers-目录：vi-gprsdial-建立文件"><a href="#2-进入-etc-ppp-peers-目录：vi-gprsdial-建立文件" class="headerlink" title="(2)进入/etc/ppp/peers/目录：vi gprsdial 建立文件"></a>(2)进入/etc/ppp/peers/目录：vi gprsdial 建立文件</h6><p>内容如下：</p><pre><code>#/etc/ppp/peers/gprsdial# This is pppd script for China Mobile, used SIMCOM SIM7100 Module# Usage: root&gt;pppd call gprs#Interface which be used is the interface which connects physics interface of  SIM7100 Module.</code></pre><p>/dev/ttyUSB3<br>115200<br>crtscts<br>modem<br>    #noauth</p><p>debug<br>nodetach<br>    #hide-password</p><p>usepeerdns<br>noipdefault<br>defaultroute<br>user “cmnet”<br>0.0.0.0:0.0.0.0<br>    #ipcp-accept-local<br>    #ipcp-accept-remote<br>    #lcp-echo-failure 12<br>    #lcp-echo-interval 3<br>    #noccp<br>    #novj<br>    #novjccomp<br>    #persist</p><p>connect ‘/usr/sbin/chat -s -v -f /etc/ppp/gprs-connect-chat’<br>    #disconnect ‘/bin/chat -v -f /etc/ppp/gprs-disconnect-chat<br>    拨号的脚本成功完成！！！</p><hr><h4 id="6-进行拨号"><a href="#6-进行拨号" class="headerlink" title="(6)进行拨号"></a>(6)进行拨号</h4><p>超级终端输入：pppd calll gprsdial<br>现象：出现以下说明拨号成功（未全部列出）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk0NDQ2NDk4?x-oss-process=image/format,png" alt></p><p>查看模块运行状态：<br>我们使用：pppd call gprsdial &amp; 将4G模块设置为后台运行，这样的话，有利于我们操作。<br>输入：ifconfig查看网络：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk0NTQ0ODc5?x-oss-process=image/format,png" alt></p><p>出现ppp0说明：4G模块确定拨号已经成功了。为了防止与本地的网络冲突，我将开发板上的网线拔掉！！</p><hr><h4 id="（7）测试"><a href="#（7）测试" class="headerlink" title="（7）测试"></a>（7）测试</h4><p>拨号之后进行测试，通过ping命令来看是否可以ping通IP和域名。</p><h6 id="1-a-ping-IP"><a href="#1-a-ping-IP" class="headerlink" title="(1)a.ping IP:"></a>(1)a.ping IP:</h6><p>出现  “ping: sendto: Network is unreachable”（内心崩溃。。。。。。。。）</p><p>解决方法：</p><p>[ping 不通ip解决] (<a href="http://www.cnblogs.com/embedded-linux/p/5258388.html" target="_blank" rel="noopener">http://www.cnblogs.com/embedded-linux/p/5258388.html</a>)</p><p>测试是否ping通baidu的IP地址。如果ping不通，需要给本机加条路由，使用如下指令：</p><pre><code>#route add default gw 10.212.18.13</code></pre><p>注：10.212.18.13：运营商的ip地址，即下图黑色部分。完美解决！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk0ODIwNTIy?x-oss-process=image/format,png" alt></p><p>查看IP信息：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk0ODUzODAx?x-oss-process=image/format,png" alt></p><h6 id="2-ping-域名："><a href="#2-ping-域名：" class="headerlink" title="(2)ping 域名："></a>(2)ping 域名：</h6><p>此时可以ping通ip但是无法ping通域名。这需要设置/etc/resolv.conf来添加DNS解析服务器的地址。<br>解决：<br>在/etc/resolv.conf 中加入：下面两句，即可成功ping通域名</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk0OTM1MDIx?x-oss-process=image/format,png" alt></p><p>DNS出现在拨号信息的末尾：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk1MDEwMDIz?x-oss-process=image/format,png" alt></p><p>成功ping通百度</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwODEzMTk1MzA5NDMy?x-oss-process=image/format,png" alt></p><p>至此，4G模块已经成功拨号。。。。。。。。。。。。。。。。。<br>若要开机自启动拨号：只需设置/etc/init.d/rcS 即可（参照网卡设置）</p><hr><h2 id="四、感悟"><a href="#四、感悟" class="headerlink" title="四、感悟"></a>四、感悟</h2><p>本人是新手，在移植的过程中遇到了很多的问题，多半是看了网上的文章，然后边学习边弄。如果有不准确的地方，还望大家勿喷，互相学习。从开始学习Linux驱动到现在，也有一段时间了，虽然还很菜，但至少不像开始一样蒙圈了。</p><hr><h2 id="五、感谢"><a href="#五、感谢" class="headerlink" title="五、感谢"></a>五、感谢</h2><p>在这个过程中，我主要参考了[在ARM Linux上实现4G模块PPP拨号上网] (<a href="http://www.linuxidc.com/Linux/2016-03/129581.htm)他的文章，还有一些相关3G模块的移植文章，再次感谢大家！！" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-03/129581.htm)他的文章，还有一些相关3G模块的移植文章，再次感谢大家！！</a></p><hr><h1 id="欢迎关注公众号：【千艺千寻】，共同成长"><a href="#欢迎关注公众号：【千艺千寻】，共同成长" class="headerlink" title="欢迎关注公众号：【千艺千寻】，共同成长"></a><strong>欢迎关注公众号：【千艺千寻】，共同成长</strong></h1><p><img src="/images/%E6%9C%AB%E6%A0%8F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SIM7100 </tag>
            
            <tag> itop4412 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
